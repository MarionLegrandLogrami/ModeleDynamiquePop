%
% !arara: pdflatex:  { action: nonstopmode, synctex: True }
% arara: bibtex
% !arara: makeglossaries
% arara: pdflatex: {action: nonstopmode, synctex: True }
% arara: pdflatex: {action: nonstopmode, synctex: True }
\documentclass[a4paper,12pt]{report}
\usepackage[nogin]{Sweave}
\usepackage[latin1]{inputenc}%encodage du fichier source
\usepackage[T1]{fontenc}%gestion des accents (pour les pdf) 
\usepackage[francais]{babel}
\usepackage{lmodern}%fonte latin modern
\usepackage{float}
\usepackage[section]{placeins}%The placeins package provides the command \FloatBarrier 

\makeatletter %%Si on ne fait pas ces lignes de commandes, le FloatBarrier ne marche pas à l'intérieur des subsection (uniquement section)
\AtBeginDocument{%
  \expandafter\renewcommand\expandafter\subsection\expandafter{%
    \expandafter\@fb@secFB\subsection
  }%
}%
\makeatother

\usepackage{amsmath}% equation numbering
\usepackage[colorlinks=true,urlcolor=blue,linkcolor=black,citecolor=black,bookmarksnumbered]{hyperref}
\usepackage{wrapfig}
\usepackage{subcaption}% pour les subfigures
%\usepackage{vmargin}
\usepackage[final]{pdfpages} 
\usepackage[left=2cm, right=2cm, top=1.5cm, bottom=1.5cm]{geometry}
\geometry{dvips,a4paper,hmargin=1.5cm,vmargin=1.5cm}
\usepackage{pdflscape}
\usepackage[font={it}]{caption}% pour des légendes en italique
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{amssymb}
\usepackage[abs]{overpic}
\usepackage[section]{placeins}%The placeins package provides the command % \FloatBarrier \let\emptyset\varnothing
\graphicspath{{illustrations/}}
%\setpapersize{A4}
%\setmarginsrb{15mm}{15mm}{15mm}{15mm}{12pt}{0mm}{0pt}{11mm}
\setcounter{secnumdepth}{10}
\usepackage[xindy,acronym]{glossaries}% pour faire un glossaire [xindy] option
\usepackage{enumitem}% pour diminuer les espaces après itemize
% [noitemsep,nolistsep] \usepackage{blindtext} %dummty text
\usepackage[round]{natbib}
\definecolor{bois}{RGB}{139,69,19}
\definecolor{brique}{RGB}{238,64,0}
\definecolor{bleu}{RGB}{16,18,138}
%\definecolor{violet}{RGB}{160,32,240}
\definecolor{jauneorange}{RGB}{205,133,0}
\definecolor{deeppink}{RGB}{255,20,147}
\definecolor{lightgoldenrod1}{RGB}{255,236,139}
\definecolor{royalblue4}{RGB}{39,64,139}
\definecolor{grisbleu}{RGB}{62,59,132}
\definecolor{vertfond}{RGB}{34,49,23}
\definecolor{vertfond2}{RGB}{57,102,45}
\definecolor{vertsurf}{RGB}{212,242,132}
\renewcommand*{\glstextformat}[1]{\textcolor{grisbleu}{#1}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}% cette commande est pour créer un ligne il faut la précéder de noident
% recommended,[toc]=> glossary in the table of contents
\hypersetup{pdfstartview=FitH} %zoom pleine page
\hypersetup{
     backref=true,%permet d'ajouter des liens dans...
     pagebackref=true,%...les bibliographies
     hyperindex=true,%ajoute des liens dans les index.
     colorlinks=true,%colorise les liens
     breaklinks=true,%permet le retour à  la ligne dans les liens trop longs
     urlcolor= cyan,%couleur des hyperliens
     linkcolor= royalblue4,%couleur des liens internes(change box color with linkbordercolor)
     filecolor=magenta,% color of file links 
     citecolor=grisbleu,
     bookmarks=true,%créé des signets pour Acrobat
     bookmarksopen=true,%si les signets Acrobat sont créés, %les afficher complètement.
     %dans les informations du document
     %pdfsubject={Mortalité dévalaison},          %sous Acrobat
     %pdfkeywords={saumon}{Salmo salar}{Modèle dynamique de population}
     }
\usepackage{etoolbox}
\makeatletter
\renewcommand{\@makechapterhead}[1]{%
  \vspace*{50\p@}%
  {\parindent \z@ \raggedright \normalfont
  \hrule                                        % horizontal line
  \vspace{10pt}%                                 % add vertical space
  \interlinepenalty\@M
  \ifnum \c@secnumdepth >\m@ne
        \huge\bfseries \thechapter\space \scshape #1\par
        \par\nobreak
        \vskip 20\p@        
  \vspace{10pt}%                                 % add vertical space
  \hrule                                        % horizontal rule
  \nobreak
  \vskip 40\p@
  }%
}
\makeatother

%\newcommand{\myparagraph}[1]{\paragraph*{#1}\mbox{}\\} %pour forcer à aller à
% la ligne en début de paragraphe

\addto{\captionsfrench}{\renewcommand{\bibname}{Références bibliographiques}}
\addto{\captionsfrench}{\renewcommand{\abstractname}{Résumé}}
\addto{\captionsfrench}{\renewcommand{\glossaryname}{Glossaire}}
\addto{\captionsfrench}{\renewcommand{\tablename}{Tableau}}

\begin{document}

<<init, echo=FALSE, eval=TRUE,results=hide >>=
##Les CODA du modèle définitif pour ce rapport = C:/Users/logrami/workspace/ModeleDynamiquePop/data/CODA/2016_12_19_Alagnon
setwd("C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/script/lateX") 
datawd<-"C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/data/CODA/"
imgwd<-"C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/script/lateX/illustrations/2016/"
tabwd<-"C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/script/lateX/tab/2016/"

library(coda)
library(lattice)
library(boot)
require(stringr)
require(xtable)
library("Hmisc")
library(ggplot2)
T=41
#paramètre pour dire qu'on veut lancer dans chaque chunk les lignes de code (=1ere fois)
chunk_true=1
@

<<init_travail, echo=FALSE, eval=TRUE, results=hide>>=
#on ne veut pas relancer les lignes dans les chunk
chunk_true=0
@


\includepdf{\Sexpr{imgwd}PageDeGarde_2016.pdf}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TABLES DES MATIERES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\newpage
\listoffigures
\newpage
\listoftables
\newpage

\sffamily
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PARTIES DU RAPPORT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Entre 2010 et 2012, Guillaume Dauphin et Etienne Prévost (INRA--UMR ECOBIOP) ont
développé un modèle de dynamique de population pour le saumon de l'Allier
(\citet{dauphin_viability_2013} : \href{http://www.plan-loire.fr/fileadmin/pce/PF_RDI/ProjetsRecherche/Docs/INRA_viabilite_saumon/33698_Rapport_final_viabilite_Saumon_Allier.pdf}{voir
le rapport en ligne}). Le développement de cet outil avait été
demandé de longue date par les acteurs de l'eau du bassin de la Loire 
et était inscrit dans le plan de gestion des poissons migrateurs (PLAGEPOMI) du
bassin de la Loire, des côtiers vendéens et de la Sèvre niortaise 2009-2013 à la
mesure 62, intitulée \og Comprendre les modalités de renouvellement de la
population : création d'un modèle de dynamique de populations \fg{}.
En 2014, grâce à une action inscrite dans le cadre des travaux du pôle
INRA-ONEMA, une opération de \og transfert \fg{} du modèle vers un opérateur de
la gestion a pu être mise en place de façon à ce que l'outil puisse continuer à servir
pour la connaissance dans une optique d'aide à la gestion.
Marion Legrand\footnote{pour toute question ou besoin d'éléments complémentaires
n'hésitez pas à me contacter par mail \href{mailto:tableau-salt-loire@logrami.fr}{\nolinkurl{tableau-salt-loire@logrami.fr}}}, animatrice du tableau de bord \og Migrateurs \fg{} du bassin de la
Loire (LOGRAMI) a donc poursuivi la mise à jour, l'amélioration et le
développement de l'outil sous la supervision d'Etienne Prévost (INRA).
Annuellement, un rapport est publié présentant les avancées et
développements réalisés pendant l'année
(\citet{legrand_transfert_2014} :
\href{http://www.migrateurs-loire.fr/telechargement/documentation/rapports/Legrand-et-Prevost-2015.pdf}{voir
le rapport en ligne}; \citet{legrand_prevost_2015}{http://www.migrateurs-loire.fr/telechargement/documentation/rapports/Legrand-et-Prevost-2016.pdf}{voir
le rapport en ligne}).
Afin que les développements du modèle soient en adéquation avec les
besoins en connaissance des acteurs de l'eau du bassin de la Loire concernés par
la gestion du saumon de l'Allier, un groupe de travail a été créé autour de ce
projet en 2014. Ce groupe\footnote{29 personnes de 21 structures différentes
sont systématiquement invitées à participer à ces réunions. Les structures
invitées sont : l'Agence de l'eau Loire-Bretagne, le Cnss, la DREAL bassin
Loire-Bretagne, Edf, l'Eptb Loire, la FDAAPPMA 03, la FDAAPPMA 15, la FDAAPPMA
42, la FDAAPPMA 43, la FDAAPPMA 48, la FDAAPPMA 63, l'Inra, Logrami, l'Onema, la
Region Centre Val-de-Loire, le Sage Alagnon, le Sage Allier aval, le Sage Dore,
le Sage Haut-Allier, le Sage Sioule et le Sigal} suit les avancés du projet et donne les orientations pour le
travail à venir (choix des thématiques). En 2014 ce groupe a permis de valider l'intérêt des acteurs du bassin pour ce projet de modélisation et de valider la poursuite du travail.
L'objet du présent rapport est de présenter les travaux menés en 2016 sur le
modèle, qu'il s'agisse de la mise à jour, des corrections et améliorations
apportées au modèle ou du développement de nouveaux scénarii de gestion.



\clearpage 
\chapter{Mise à jour, corrections et améliorations du modèle}
\label{maj_mod}

\section{Corrections et mise à jour}
\label{corr}
En 2014, un travail important avait conduit à l'ajout, pour les juvéniles, d'un
paramètre de surmortalité lié à l'impact de l'ouvrage de Poutès \citep{legrand_transfert_2014}.
Cet ajout avait amené à revoir à la baisse les quantités de juvéniles à
l'origine des retours d'adultes à Vichy et donc à une vision plus
optimiste du taux de transition entre les juvéniles et les adultes.
La poursuite du travail sur le modèle en 2015 a permis de mettre en évidence une
erreur dans la prise en compte du homing lors du retour des adultes, suites aux
modifications apportées en 2014.
En effet, la répartition des adultes arrivant à Vichy est dépendante à la fois
des surfaces de production disponibles et accessibles (habitat), et de la
faculté des adultes à revenir à leur frayère (homing), auxquelles s'ajoute
d'éventuels problèmes de franchissement à la montaison.
Or les modifications apportées à la production de juvéniles en amont de Poutès
(surmortalité à la dévalaison liée à la présence de l'ouvrage) n'ont pas été
répercutées sur la composante \og homing \fg{} de la répartition des adultes.
Ainsi, dans le modèle publié en 2015 la part d'adultes accédant aux zones de
production situées en amont de Poutès était écrite comme suit (equation \ref{eq_rep_ad}) :
\begin{equation}
\label{eq_rep_ad}
  \begin{align}
  $L\_mu\_p\_poutes[t] <- L\_ratio\_juv\_P[t] + adjust\_p\_P$
  \end{align}
\end{equation}
Avec L\_mu\_p\_poutes=moyenne de la probabilité en échelle logit (mu\_p\_poutes)
de passer en amont de Poutès, L\_ratio\_juv\_P=facteur de répartition des
adultes à la fois en fonction des surfaces disponibles (répartition idéale libre) et en fonction de l'endroit où ils sont nés (homing) (cf.
équation \ref{eq_ratio_juv}), adjust\_p\_P=variable d'ajustement
pour prendre en compte les difficultés de migration à la montaison au niveau de
l'ouvrage de Poutès, t=années.
\\
\noindent L\_ratio\_juv\_P étant calculé de la manière suivante (equation
\ref{eq_ratio_juv}) :
  
\begin{subequations}\label{eq_grp}
  \begin{gather}
  %\begin{split}
  $L\_ratio\_juv\_P[t] <- rho$ \times $$\frac{S\_juv\_P[t]}{S\_juv\_L[t] + S\_juv\_P[t]}$ + (1-rho)$ \times $ratio\_juv\_prod\_P[t]$
  \label{eq_ratio_juv}
  %\end{split}
  \end{gather}
  \begin{gather}
  \intertext{Avec} %pour ajouter un texte court
  $ratio\_juv\_prod\_P[t] <- $\frac{Juv\_poutes[t]}{Juv\_langeac[t] + Juv\_poutes[t]}$$
  \label{eq_ratio_juv_prod}
  \end{gather}
\end{subequations}

\noindent Avec rho=un facteur pondérateur de la répartition des adultes entre
la composante habitat et la composante homing, S\_juv\_P=les surfaces disponibles pour la croissance des
juvéniles en amont de Poutès, S\_juv\_L=les surfaces disponibles pour la
production des juvéniles entre Langeac et Poutès, ratio\_juv\_prod\_P=le ratio
des juvéniles produits sur la zone en amont de Poutès (cf. equation \ref{eq_ratio_juv_prod})

Ceci a été corrigé dans la
nouvelle version du modèle en remplaçant l'équation
\eqref{eq_ratio_juv_prod} par l'équation \eqref{eq_ratio_juv_prod_new} :
\begin{equation}
\label{eq_ratio_juv_prod_new}
  \begin{align}
    $ratio\_juv\_prod\_P[t] <- $\frac{Juv\_poutes[t] \times rho\_poutes}{Juv\_langeac[t] + Juv\_poutes[t] \times rho\_poutes}$$
  \end{align}
 \end{equation}
Avec rho\_poutes=ratio de survie des juvéniles présents en amont de
Poutès, lié à la présence de l'ouvrage et aux mortalités induites lors de la
dévalaison des smolts.\\

La même correction a été apportée au ratio de juvéniles produits entre Langeac
et Poutès à partir de l'ouverture du barrage en 1986 (équation
\ref{eq_ratio_juv_prod_L}).
\begin{equation}
\label{eq_ratio_juv_prod_L}
  \begin{align}
    $ratio\_juv\_prod\_L[t] <- $\frac {Juv\_langeac[t] + Juv\_poutes[t] \times rho\_poutes}{Juv\_vichy[t] + Juv\_langeac[t] + Juv\_poutes[t] \times rho\_poutes}$$
  \end{align}
\end{equation}

\\
L'année 2015 a également été l'occasion de mettre à
jour le modèle avec les données de 2014. En effet, la mise à jour annuelle du modèle a été jugée pertinente par les membres du groupe de suivi du projet. Cela permet d'ajouter
régulièrement de nouvelles données dans le modèle ce qui, en plus de contribuer
à l'amélioration de la robustesse des estimations déduites du modèle, permet de
pouvoir présenter des sorties graphiques régulièrement mises à jour (cf. section \ref{res_model}).

\section{Améliorations}
\subsection{Hypothèse d'une \textit{fitness} similaire entre les tacons 0+
sauvages et les tacons 0+ issus du déversement d'alevin}
\label{fitness}

<<loi_beta, echo=FALSE, eval=TRUE,results=hide>>=
if (chunk_true==1){
	x <- seq(0, 1, length=10000)
	f=dbeta(x,2,2)
	pdf(file=str_c(imgwd,"loi_beta_2_2.pdf"),width = 5, height = 5)
	plot(x,f,type="l",ylab="")
	dev.off()
	
	rho_surv=read.coda("C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/data/CODA/2016_03_01/rho_surv_juvCODAchain1.txt","C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/data/CODA/2016_03_01/rho_surv_juvCODAindex.txt")
	pdf(file=str_c(imgwd,"rho_surv.pdf"),width=8,height=5)
	plot(rho_surv,main="surv")
	dev.off()
}
@

Dans le modèle mis au point en 2013 \citep{dauphin_viability_2013}, l'hypothèse
suivante avait été avancée. A partir du stade tacon 0+, il est considéré que
le taux de transition est le même jusqu'au stade adulte de retour à Vichy,
quelle que soit l'origine du poisson (sauvage ou élevage). Cette hypothèse avait
été faite notamment compte-tenu du manque d'information pour proposer une
hypothèse alternative.
En 2014, lors de la réunion du groupe de travail sur le modèle dynamique de
population (Annexe \ref{Annexe2}), les participants ont émis le souhait de
retravailler cette hypothèse afin de vérifier sa validité. En effet, ce point est
important car s'il existe une bonne raison de penser que les poissons sauvages
survivent différemment des poissons d'élevage entre le stade 0+ et l'adulte
de retour, alors cela influence directement le taux de survie (qui est global pour
les deux origines). Des répercussions, potentiellement importantes,
pourraient alors exister sur les projections lorsque nous simulons l'arrêt des
déversements sur 20 ans (puisque nous n'avons plus qu'une seule origine,
c'est-à-dire des saumons sauvages).

\paragraph*{Synthèse bibliographique}


\paragraph*{Test d'ajout d'une variable dans le modèle}

Parallèlement à la synthèse bibliographique et pour étudier la question
sous un angle différent, nous avons procédé à un test d'ajout d'un facteur de
survie spécifique aux juvéniles déversés dans le modèle. L'idée était de laisser
la possibilité d'estimer ce paramètre supplémentaire grâce à l'ensemble des données utilisées.
Jusqu'ici la densité totale moyenne de juvénile dans le système s'écrivait
(equation \ref{eq_d_tot}) :
\begin{equation}
\label{eq_d_tot}
  \begin{align}
   $d$_{juv}$tot\_moy = d$_{sauvage}$moy + d$_{aleviné}$moy + d$_{oeufs}$moy$
  \end{align}
\end{equation}
Avec d$_{juv}$tot\_moy = la densité moyenne totale de juvéniles 0+ dans le
système, d$_{sauvage}$moy = la densité moyenne de juvéniles 0+ sauvage,
d$_{aleviné}$moy = la densité moyenne de juvéniles déversés au stade alevin et ayant survécu
jusqu'au stade tacon 0+, d$_{oeufs}$moy = la densité totale de juvéniles issus
des déversements au stade oeufs en incubateurs et ayant survécu
jusqu'au stade tacon 0+.

Le test que nous avons réalisé a consisté à modifier l'equation \eqref{eq_d_tot}
de la façon suivante (equation \ref{eq_d_tot_test}) :

\begin{equation}
\label{eq_d_tot_test}
  \begin{align}
    $d$_{juv}$tot\_moy = d$_{sauvage}$moy + d$_{aleviné}$moy$ \times $surv + d$_{oeufs}$moy$
  \end{align}
\end{equation}
Avec surv = facteur de survie pour les juvéniles issus des alevinages.

En l'absence de connaissances précises nous avons mis un prior peu informatif
sur le paramètre surv, à savoir une loi beta(2,2) (figure \ref{loi_beta}). Ce prior
initial indique ainsi que le paramètre de survie des juvéniles issus des
alevinages peut prendre l'ensemble des valeurs entre 0 et 1 (inclus) mais avec
\textit{a priori} une probabilité très faible que le paramètre soit égal à 0
(c'est-à-dire que les juvéniles déversés ne survivent pas du tout) ou 1 (c'est-à-dire que les juvéniles déversés survivent aussi bien que les natifs), la
valeur centrale (0.5) étant la valeur la plus probable.\\


La distribution de probabilité du paramètre de survie \textit{surv} n'est
quasiment pas mise à jour (figure \ref{rho_surv}).
Ceci confirme que nous ne disposons pas actuellement de données permettant de
valider une hypothèse alternative à celle d'une survie similaire des juvéniles 0+ jusqu'aux adultes de retour. \\
Le groupe de travail qui suit et accompagne le travail sur ce projet est réuni
le 6 juillet 2015 et décide d'arrêter là le travail sur cette thématique (cf.
Annexe \ref{Annexe2}).


\subsection{Renforcement de la relation de calibration}
\label{calib}

La relation de calibration entre les densités de tacons 0+ et les nombres
d'individus capturés en 5 minutes effectives de pêche (pêche indice
d'abondance) est un élément important du modèle puisqu'il permet de convertir
toutes les pêches réalisées depuis 1994 sur le protocole des indices d'abondance
en 5 minutes, en densité. Jusque là cette relation de calibration était
construite grâce à 9 points de pêche réalisés dans la rivière Allier, sur le
double protocole pêche d'indice d'abondance en 5 minutes et pêche complète. Lors de la réunion du groupe de travail sur le modèle (le 19 novembre 2014 - cf.
Annexe \ref{Annexe2}), l'idée de renforcer cette relation via l'ajout de nouveaux points
avait été mentionnée.
Les 29 et 30 septembre 2015, grâce à la mobilisation de 25 personnes
\footnote{nous tenons à cette occasion à remercier chaleureusement l'ensemble des agents ayant participé à cette opération. Ce travail n'aurait pu être réalisé sans la participation de l'association MIGADO, MRM, la Fédération de pêche de l'Allier, la Fédération de
pêche de l'Eure, la participation de la DREAL de bassin Loire-Bretagne et
l'ensemble de l'équipe LOGRAMI}, 4 nouveaux points sont venus
enrichir la relation de calibration du modèle. Ces points ont été choisis de
façon à avoir au moins un site avec une faible abondance, un avec une abondance
moyenne et un avec une abondance forte. D'autre part, un point a été réalisé sur
la rivière Alagnon (secteur 1 du modèle avec l'axe
Allier entre Vichy et Langeac et la Dore) de façon à vérifier
la validité de l'utilisation de cette relation sur d'autres axes inclus dans le
modèle. \\
Par rapport aux abondances visées (un site faible, un site moyen et un site
fort), nous pouvons observer que le site faible a bien pû être échantillonné
(station d'orbeil avec 5 tacons 0+ en 5 minutes). En revanche, nous espérions un
meilleur résultat en terme de nombre d'individus 0+ par 5 minutes pour le site
de Pontgibert sur lequel nous avions observé en moyenne sur les trois dernières
années de très bons résultats de pêche en 5 minutes (moyenne 2012-2014=179.3 $\pm$67.6).
Il serait très intéressant d'avoir un point avec une
très forte abondance (>175 tacons 0+ par 5 minutes) et cela doit rester un
objectif pour une prochaine campagne de pêche. 


\subsection{Développement de nouvelles sorties graphiques : répartition des
juvéniles en fonction des secteurs}
\label{fig_new}

En plus de la mise à jour annuelle du modèle et des nombreuses
figures déjà existantes (cf. section \ref{res_model}), nous avons mis à profit
l'année 2015 pour développer de nouvelles sorties graphiques (cf. section
\ref{res_model_nlle_fig} figures \ref{rep_juv_bassin} et
\ref{rep_juv_wild_bassin}). Ces nouvelles figures permettent de visualiser la
répartition des juvéniles dans les différents secteurs pris en compte dans le modèle, mais sous un angle différent de ce qui était
fait précédemment. En effet, jusque là nous représentions la répartition des
cohortes de juvéniles à l'origine des retours d'adultes d'une année \textit{n}
(cf. section \ref{res_model} figure \ref{Juv_Prod_Ratio}) \footnote{Par exemple, la cohorte de juvéniles à l'origine des retours d'adultes
2014 ($J^{coh}_{2014,i}$) correspond à $\frac{1}{3}$ des juvéniles produits en 2009, $\frac{1}{3}$
des juvéniles produits en 2010 et $\frac{1}{3}$ des juvéniles produits en 2011}.
Il s'agit ici de représenter la répartition des juvéniles \og produits \fg{} (dans le
milieu naturel ou déversés) une année donnée. La figure est déclinée à la fois
pour les juvéniles toutes origines confondues (sauvage et élevage) et pour les
juvéniles sauvages seuls. Ces figures sont intéressantes pour détecter de
potentiels changement dans la répartition des individus (juvéniles et géniteurs) dans les 3 secteurs du modèle. 
Compte-tenu du fait que la productivité de ces 3 secteurs n'est pas similaire
(cf. section \ref{res_model} figure \ref{fig_dd}), un changement dans la répartition des individus peut entrainer 
des modifications importantes sur la viabilité de la population.\\
%Ces figures seront également réalisées pour les différentes simulations et
%projections à 20 ans (cf. section \ref{res_simul}).

\clearpage

\chapter{Développement d'un nouveau scénario de gestion : l'aménagement des
ouvrages hydroélectriques pour la dévalaison}
\label{scenario_deval}
<<deval, echo=FALSE, eval=TRUE, results=hide>>=

if (chunk_true==1){

ce<-c(rep("Allier",3),rep("Alagnon",2),rep("Dore",5))	
ouv<-c("Langeac","Chambon de Cerzat","Vieille-Brioude","Aurouze","Babory","Chalard","Chanteliauze-Olliergues","Decours","St Gervais sous Meymont","Prades-Sauviat")
morta<-c(7.4,8.4,9.8,15.3,11.4,16.2,8.5,9.3,10,14.7)	
mort<-as.data.frame(cbind(ce,ouv,morta))
names(mort)<-c("Cours d'eau","Ouvrage","Mortalité (%)")

tmort<-xtable(x=mort,label="p_morta",caption=c("Taux de mortalité (en pourcentage) induit par chaque ouvrage hydroélectrique. Pour chaque cours d'eau, les ouvrages sont ordonnés de l'amont vers l'aval","Taux de mortalité (en pourcentage) induit par chaque ouvrage hydroélectrique"))

o<-print(tmort, file = str_c(tabwd,"pourc_morta.tex"), 
		table.placement = "h",#indique comment positionner la table
		caption.placement = "top",
		NA.string = ".",
		include.rownames=TRUE,
		tabular.environment="tabularx",
		width="0.7\\textwidth")


ce2<-rep(c("Allier (Vichy-Langeac)","Alagnon","Dore"),2)
ratio75_03<-c(0.66,0.14,0.2,0.61,0.08,0.31)
ratio04_T<-c(0.43,0.44,0.13,0.46,0.3,0.24)
ratio_type<-c(rep("surf+prod",3),rep("surf",3))
ratio<-as.data.frame(cbind(ce2,ratio_type,ratio75_03,ratio04_T))
names(ratio)<-c("Cours d'eau","Type de calcul","$r_{river}$\\_75-03",
"$r_{river}$\\_04-14")
ratio<-ratio[,-2]#on enlève type calcul pris en charge par n.rgroupes et rgroup
#On utilise latex() et non xtable() car ce dernier n'arrive pas à mettre surf en indice dans l'en-tête du tableau

tratio<-latex(ratio,        
		title=str_c(),
		rowname="",
		rowlabel="",
		where="ht",
		longtable=FALSE,
		col.just=strsplit("l l l", " ")[[1]],
		rgroup=c("\\textit{prorata} surfaces+productivité","\\textit{prorata} surfaces"),
		n.rgroup=table(ratio$ratio_type),
		label="ratio",
		caption="Ratio à appliquer sur chacun des axes du secteur 1 (Allier en aval de Langeac, Alagnon et Dore) en fonction de deux méthodologies de calcul différentes. \\textit{prorata} surfaces ne tient compte que de la disponibilité des habitats productifs 
sur chacun des axes, \\textit{prorata} surfaces+productivité tient compte à la fois du ratio d'habitats productifs sur chacun des axes mais également de la productivité de ces axes via un coefficient pondérateur
issu de l'analyse des pêches électriques sur chacun de ces axes. $r_{river}$\\_75-03 étant le ratio à appliquer à chaque cours d'eau sur la période 1975-2003 (c'est-à-dire avant l'ouverture de Grand Pont sur l'Alagnon) et $r_{river}$\\_04-14 le ratio à appliquer depuis 2004.",
		caption.lot="Ratio à appliquer sur chacun des axes du secteur 1 pour répartir les juvéniles produits dans le secteur 1 (Vichy-Langeac + Allier + Dore)",		
		file=str_c(tabwd,"ratio_surf.tex"))	


ce3<-c(rep("Allier",4),rep("Alagnon",2),rep("Dore",5))	
ouv3<-c("Poutès","Langeac","Chambon de Cerzat","Vieille-Brioude","Aurouze","Babory","Chalard","Chanteliauze-Olliergues","Decours","St Gervais sous Meymont","Prades-Sauviat")
secteur<-c("Amont Poutès","Langeac-Poutès",rep("Vichy-Langeac",9))
interbar75_85<-c(0,1,0.0884,0.281,0,0,0.395,0.029,0.012,0.06,0.156)
interbar86_03<-c(1,1,0.0884,0.281,0,0,0.395,0.029,0.012,0.06,0.156)
interbar04_14<-c(1,1,0.0884,0.281,0.303,0.174,0.395,0.029,0.012,0.06,0.156)
interbar<-as.data.frame(cbind(ce3,secteur,ouv3,interbar75_85,interbar86_03,interbar04_14))
names(interbar)<-c("Cours d'eau","Secteur","Ouvrage","$r_{intbar}$75-85","$r_{intbar}$86-03","$ratio_{intbar}$04-14")

tinterbar<-latex(interbar,        
		title=str_c(),
		rowname="",
		rowlabel="",
		where="ht",
		longtable=FALSE,
		label="interbar",
		caption="Fraction de juvéniles produits impactés par les ouvrages situés dans leur secteur. 
				Pour l'Allier, tous les juvéniles produits dans les secteurs situés en amont d'un certain ouvrage et ayant survécu 
				à la dévalaison dans les ouvrages de leur secteur sont impactés par cet ouvrage.
				$r_{intbar}$75-85 représente la fraction de juvéniles impactés par chaque ouvrage sur la période 1975-1985 
				(c'est-à-dire avant l'ouverture de Poutès sur l'Allier), $r_{intbar}$86-03 pour la période 1986-2003 (avant l'ouverture de Grand Pont sur l'Alagnon), et $r_{intbar}$04-14 représente 
				la fraction de juvéniles impactés par chaque ouvrage depuis 2004.",
		caption.lot="Fraction de juvéniles produits impactés par les ouvrages situés dans leur secteur.",
		file=str_c(tabwd,"ratio_interbar.tex"))


}
@


Conformément à ce qui avait été décidé lors du groupe de travail du 19 novembre
2014 (cf. Annexe \ref{Annexe2}), nous avons développé en 2015 une simulation
visant à évaluer l'effet de la suppression de l'impact des ouvrages
hydroélectriques lors de la dévalaison des smolts. Pour cela, 
nous avons réutilisé les résultats de l'étude DEVALPOMI
\citep{briand_devalaison_2015} qui estime pour chaque ouvrage du bassin
Loire-Bretagne une mortalité lors de la dévalaison des anguilles et des smolts
\footnote{les ouvrages faisant l'objet de grilles fines (<2,5 cm) ont été jugés
non impactants. La mortalité liée à ces ouvrages est donc de 0}.
Cependant, l'impact de l'ouvrage de Poutès étant déjà estimé dans le cadre du
modèle dynamique de population, nous n'utilisons pas l'estimation de la
mortalité lors de la dévalaison issue de DEVALPOMI pour cet ouvrage.
La figure \ref{devalpomi} présente les 10 ouvrages hydroélectriques engendrant (en plus du barrage de Poutès)
des mortalités dans le territoire pris en compte par le modèle \footnote{L'ouvrage de Chambezon (Alagnon) est absent de cette cartographie car dans le projet DEVALPOMI, cet ouvrage a été indiqué, de façon erronnée, comme
équipé de grilles fines.
Dans une prochaine version de DEVALPOMI cette erreur sera corrigée, et il sera
alors nécessaire de relancer la simulation pour prendre en compte les
mortalités liées à cet ouvrage.}.
Le tableau \ref{p_morta} présente les mortalités engendrées pour les smolts au
passage de chaque ouvrage hydroélectrique telles qu'estimées dans l'étude
DEVALPOMI (l'estimation liée à l'ouvrage de Poutès est absente de ce tableau car
non utilisée dans la suite. Pour information, la mortalité estimée pour cet
ouvrage dans le projet DEVALPOMI est de 32.2\%).


De façon à prendre en compte le plus justement possible l'impact des
ouvrages sur les juvéniles, nous faisons l'hypothèse d'une répartition des
juvéniles au \textit{prorata} des surfaces disponibles. Cela amène
l'introduction dans le modèle de deux coefficients pondérateurs :
\begin{itemize}
    \item Pour le secteur 1 (Vichy-Langeac + Alagnon + Dore), on applique un
    coefficient pour répartir les juvéniles au \textit{prorata} des surfaces disponibles dans ces 3 secteurs. Ce
    coefficient prend en compte l'ouverture en 2004 de l'ouvrage de Grand Pont sur
    l'Alagnon (et le gain important de surfaces que cela a engendré pour
    ce cours d'eau) (tableau \ref{ratio}).
    \item Chaque ouvrage n'impacte que les juvéniles produits à l'amont. Ainsi,
    Poutès qui se situe en limite aval de son secteur (secteur 3) va impacter 100\% des juvéniles produits dans le secteur 3.
    En revanche, Chambon de Cerzat qui se situe près de la limite amont du
    secteur 1 (Vichy-Langeac) ne va impacter que la toute petite fraction de
    juvéniles produite entre la limite amont de ce secteur et l'ouvrage
    (figure \ref{devalpomi} et tableau \ref{interbar}). Les impacts
    se cumulant, l'ouvrage de Chambon de Cerzat, par exemple, impactera (en
    plus de la fraction de juvénile située en amont de l'ouvrage dans le secteur
    1) tous les juvéniles survivants issus des secteurs situés en amont (à savoir les juvéniles survivants produits 
    dans les secteurs 2 et 3). 
\end{itemize}


\noindent Ainsi, pour les juvéniles produits en amont de Poutès, nous avons :
\begin{equation}
\label{eq_morta_1}
  \begin{align}
   $Juv\_surv$_{Poutes}$[t] <- Juv$_{poutes}$[t]$ \times $r$_{intbar}$\_P[t]$
   \times $rho$\_{poutes}$$ \times $surv$_{L}$$ \times $surv$_{CC}$$ \times
   $surv$_{VB}$$
  \end{align}
\end{equation}

\\
\noindent Pour les juvéniles produits entre Langeac et Poutès, nous avons :
\begin{equation}
\label{eq_morta_2}
  \begin{align}
    $Juv\_surv$_{Langeac}$[t] <- Juv$_{langeac}$[t]$ \times $r$_{intbar}$\_L[t]$ \times $surv$_{L}$$ \times $surv$_{CC}$$ \times $surv$_{VB}$$
  \end{align}
\end{equation}


\noindent Pour les juvéniles produits sur l'Allier entre Vichy et Langeac, nous
avons pour chaque tronçon interbarrage :

\begin{equation}
\label{eq_morta_3}
  \begin{align}
  $Juv\_surv$_{Vichy}$CC[t] &<- $Juv$_{vichy}$[t]$ \times $r$_{riv}$\_Allier[t]$ \times $r$_{intbar}$\_V$_{CC}$[t]$ \times $surv$_{CC}$$ \times $surv$_{VB}$$  \\
  $Juv\_surv$_{Vichy}$VB[t] &<- $Juv$_{vichy}$[t]$ \times $r$_{riv}$\_Allier[t]$ \times $r$_{intbar}$\_V$_{VB}$[t]$ \times $surv$_{VB}$$ \\
  $Juv\_surv$_{Vichy}$non$_{impacté}$[t] &<- $Juv$_{vichy}$[t]$ \times $r$_{riv}$\_Allier[t]$ \times $(1-(r$_{intbar}$\_V$_{CC}$[t]+r$_{intbar}$\_V$_{VB}$[t]))$$
 \end{align}
\end{equation}

\\
\noindent Le nombre de juvéniles sortant du secteur Vichy-Langeac (Allier) étant
alors :
\begin{equation}
\label{eq_morta_4}
  \begin{align}
    $Juv\_surv$_{Vichy}$Allier[t] <- Juv\_surv$_{Vichy}$CC[t] +
    Juv\_surv$_{Vichy}$VB[t] + Juv\_surv$_{Vichy}$non$_{impacté}$[t]$
   \end{align}
\end{equation}

\noindent Avec Juv\_surv$_{Poutes}$, Juv\_surv$_{Langeac}$ et
Juv\_surv$_{Vichy}$Allier = respectivement les juvéniles survivants des secteurs
3, 2 et 1, Juv$_{poutes}$, Juv$_{langeac}$ et Juv$_{vichy}$ = respectivement les juvéniles
\og produits \fg{} (dans le milieu naturel ou déversés) par les secteurs Amont
de Poutès, Langeac-Poutès et Vichy-Langeac + Alagnon + Dore, r$_{intbar}$\_P,
r$_{intbar}$\_L, r$_{intbar}$\_V = respectivement la fraction de juvéniles impactée par chaque
ouvrage dans les secteurs 3, 2 et 1. Il est important de noter que les secteurs
2 et 3 ne sont impactés que par un ouvrage chacun (qui représente la limite aval
de chacune de ces deux zones), et que donc r$_{intbar}$\_L[t] et
r$_{intbar}$\_P[t] valent 1. En revanche, le secteur 1 est impacté sur l'Allier 
par 2 ouvrages (r$_{intbar}$\_V$_{CC}$ pour la fraction de juvéniles
produite sur le secteur 1 et impactée par l'ouvrage de Chambon de Cerzat et
r$_{intbar}$\_V$_{VB}$ pour la fraction de juvéniles produites comprises entre
l'aval du barrage de Chambon de Cerzat et l'amont du barrage de
Vieille-Brioude), r$_{riv}$\_Allier = le ratio de surfaces productives
disponibles sur l'Allier entre Vichy et Langeac par rapport aux surfaces totales
du secteur 1, rho$\_{poutes}$ = paramètre de survie lié aux conditions de dévalaison à l'ouvrage de Poutès, surv$_{L}$, surv$_{CC}$, surv$_{VB}$ = le taux de
survie à chacun des ouvrages hydroélectriques, respectivement Poutès, Langeac,
Chambon de Cerzat et Vieille Brioude, Juv\_surv$_{Vichy}$non$_{impacté}$ = les
juvéniles produits sur le secteur Vichy-Langeac sur la rivière Allier en aval de
toutes centrales hydroélectriques.\\


\\
\noindent Le même principe est appliqué à la Dore et à
l'Alagnon, et les juvéniles survivants sortant du secteur 1 se calculent
finalement de la façon suivante (équation \ref{eq_morta_5}) :
\begin{equation}
\label{eq_morta_5}
  \begin{align}
    $Juv\_surv$_{Vichy}$[t] <- Juv\_surv$_{Vichy}$Allier[t] + Juv\_surv$_{Vichy}$Alagnon[t] + Juv\_surv$_{Vichy}$Dore[t]$
   \end{align}
\end{equation}
\noindent Avec Juv\_surv$_{Vichy}$Alagnon et Juv\_surv$_{Vichy}$Dore
respectivement les juvéniles produits survivants de l'Alagnon et de la Dore.\\

\\
La Dore est un cours d'eau qui, malgré les surfaces
importantes de production de juvéniles présentes (environ 24\% des surfaces
d'équivalent radier-rapide dans l'ensemble du secteur pris en compte
par le modèle \citep{minster_err_1999}), est considérée comme peu productive. 
Afin de ne pas surestimer les juvéniles produits sur ce cours d'eau et donc de
ne pas surestimer l'impact des 5 ouvrages hydroélectriques associés (figure
\ref{devalpomi}), nous réalisons une deuxième modélisation prenant à la fois en
compte les surfaces productives sur chacun des axes du secteur 1 mais également
un facteur correctif prenant en compte la productivité de ces axes. Ce facteur
reflète les résultats obtenus lors des pêches électriques d'indice d'abondance
dans les différents tronçons du secteur 1 (Allier en aval de Langeac, Alagnon et
Dore) et provient des analyses réalisées dans le cadre de DEVALPOMI
\citep{briand_devalaison_2015}(tableau \ref{ratio}).

En plus de ces deux modélisations et sur avis du groupe de travail
accompagnant le projet (réunion du 10 décembre 2015), nous
réalisons également une modélisation avec l'hypothèse d'une production en
juvéniles nulle sur la Dore. Cela permet de modéliser trois hypothèses, deux extrêmes une qui sur-évalue (prise en compte uniquement des surfaces de production des juvéniles)
et l'autre qui sous-evalue (hypothèse d'une production nulle en juvéniles sur la Dore) l'impact des ouvrages de la Dore, et une hypothèse intermédiaire utilisant les différentes données
disponibles (prise en compte des surfaces de production des juvéniles pondérées par les résultats des pêches électriques), qui semble \textit{a priori} plus raisonnable.
Les résultats de l'ensemble de
ces modélisations sont présentés à la section \ref{res_deval}.


\clearpage
\chapter{Résultats}
\label{res}
%\textcolor{red}{bien penser à mettre pour toutes les projections les graphs de
% répartition adultes et juvéniles}

\noindent Deux types de résultats sont présentés ici :
\begin{itemize}
  \item les résultats du modèle de dynamique de population (section \ref{res_model}),
  \item les résultats des différentes simulations développées pour analyser la
  dynamique et la viabilité de la population à l'horizon de 20 ans sous
  différents scénarii (section \ref{res_simul}).
\end{itemize}
Pour l'ensemble de ces projections nous avons fait l'hypothèse que la stochasticité des
conditions environnementales reste la même que celle des années précédentes.

\section{Modèle dynamique de population}
\label{res_model}

La section \ref{res_model} présente l'ensemble des figures mises à jour avec les
données 2014 et les corrections apportées en 2015.
Les nouvelles figures développées en 2015 concernant la répartition des
juvéniles (cf. section \ref{fig_new}) y sont également
présentées.

\subsection{Relation de calibration entre les densités de tacons 0+ et les
indices d'abondance en 5 minutes}
\label{res_calibration}

<<calib, echo=FALSE, eval=TRUE, results=hide>>=
if (chunk_true==1){
#Tableau des résultats des 13 points de pêche
ce<-c(rep("Allier",12),"Alagnon")
nom<-c("Vabres","Pontgibert-radier","St Julien des Chazes-Chapelle","St Arcons-aval pont","Truchon","La Vialette-camping","Monistrol-camping","Lavoûte Chillac-camping","Chambon de Blassac-RD","Vabres","Pontgibert-radier","Orbeil","Pont de Brugeilles")
annee<-c("1997",rep("2000",5),rep("2001",3),rep("2015",4))
surf<-c("1210","464","1134","751","1854","828","2880","1192","752","1400","890","3000","1239")
IA<-c(52,131,120,159,15,61,82,21,21,61,108,5,49)
p_1<-c(222,83,221,296,50,140,136,46,21,408,239,40,267)
p_2<-c(68,34,132,60,21,45,121,31,14,197,71,19,117)
tab<-as.data.frame(cbind(ce,nom,annee,surf,IA,p_1,p_2))
names(tab)<-c("Cours d'eau","Station","Année","Surf. pêchée","0+ IA","0+
p1","0+ p2")

tabt<-xtable(x=tab,label="calib",caption=c("Détail des 13 points de pêche
réalisés sur le double protocole des pêches indice d'abondance et des pêches complètes. Les résultats des pêches en 5min sont 
présentés dans la colonne 0+ IA, les résultats des pêches complètes au premier passage dans la colonne 0+ p1, et ceux du deuxième 
passage dans la colonne 0+ p2. Surf. pêchée étant la surface pêchée en m\\up{2}","Détail des 13 points de pêche
réalisés sur le double protocole des pêches indice d'abondance et des pêches complètes"))

o<-print(tabt, file = str_c(tabwd,"calib.tex"), 
		table.placement = "h",#indique comment positionner la table
		caption.placement = "top",
		NA.string = ".",
		include.rownames=TRUE,
		tabular.environment="tabularx",
		width="\\textwidth")

#--------------------------------------------------------------------------------
#Copier - Coller du script workspace/Modèle/script/analyse retro/calibration.r
#--------------------------------------------------------------------------------
IA=c(52,82,131,120,159,15,21,21,61,61,108,49,5)
d=read.coda(str_c(datawd,"calibration/2015_10_06/dCODAchain1.txt"),str_c(datawd,"calibration/2015_10_06/dCODAindex.txt"),2001,10000)

q_d_v=array(rep(1,13*5),dim=c(13,5))

for(i in 1:13){
	q_d_v[i,]=quantile(d[,i],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}

q.d_1=quantile(d[,1],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
q.d_2=quantile(d[,2],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
q.d_3=quantile(d[,3],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
q.d_4=quantile(d[,4],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
q.d_5=quantile(d[,5],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
q.d_6=quantile(d[,6],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
q.d_7=quantile(d[,7],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
q.d_8=quantile(d[,8],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
q.d_9=quantile(d[,9],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
q.d_10=quantile(d[,10],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
q.d_11=quantile(d[,11],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
q.d_12=quantile(d[,12],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
q.d_13=quantile(d[,13],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)

q.d=rbind(q.d_1,q.d_2,q.d_3,q.d_4,q.d_5,q.d_6,q.d_7,q.d_8,q.d_9,q.d_10,q.d_11,q.d_12,q.d_13)


d_fake=read.coda(str_c(datawd,"calibration/2015_10_06/d_fakeCODAchain1.txt"),str_c(datawd,"calibration/2015_10_06/d_fakeCODAindex.txt"),5001,10000)
d_fake_old=read.coda(str_c(datawd,"calibration/2014_05_24_GuillaumeDauphin/d_fakeCODAchain1.txt"),str_c(datawd,"calibration/2014_05_24_GuillaumeDauphin/d_fakeCODAindex.txt"))

#Graphes
#densities

d_fake_q=array(rep(0,1500),dim=c(300,5) )
d_fake_old_q=array(rep(0,1500),dim=c(300,5))

IA_fake=seq(1,300,1)
IA_fake_old=seq(1,300,1)

for (i in 1:300){
	d_fake_q[i,]=quantile(d_fake[,i],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
	d_fake_old_q[i,]=quantile(d_fake_old[,i],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}

pdf(file=str_c(imgwd,"RelationCalibration_2015_10_07.pdf"),width=5,height=5)
plot(1,1,type="n",axes=FALSE,xlim=c(0,300),xlab="Nombre de tacons 0+ pêchés en 5 minutes (IA)",ylim=c(0,1.2),ylab="densité (0+ / m-2)",main="")

# trace l'axe des ordonnées
axis(2,at = seq(0,1.2,0.2),cex.axis = 0.8,las = 1,col = "black")
# trace l'axe des abscisses
axis(1,at = seq(0,300,25),cex.axis = 0.8,las = 1,col = "black")

points(IA_fake,d_fake_q[,3],type="l",col="red",lwd=1.5)
points(IA_fake,d_fake_q[,1],type="l",col="red",lwd=1.5,lty=2)
points(IA_fake,d_fake_q[,5],type="l",col="red",lwd=1.5,lty=2)

points(IA_fake_old,d_fake_old_q[,3],type="l",col="grey",lwd=1.5)
points(IA_fake_old,d_fake_old_q[,1],type="l",col="grey",lwd=1.5,lty=2)
points(IA_fake_old,d_fake_old_q[,5],type="l",col="grey",lwd=1.5,lty=2)

k=2

for(i in 1:9){
	
	#whiskers
	#95%
	segments(IA[i]-4,q.d[i,5],IA[i]+4,q.d[i,5])
	segments(IA[i],q.d[i,4],IA[i],q.d[i,5])
	
	#5%
	segments(IA[i]-4,q.d[i,1],IA[i]+4,q.d[i,1])
	segments(IA[i],q.d[i,2],IA[i],q.d[i,1])
	
	
	#boxplot
	polygon(c(IA[i]-4,IA[i]+4,IA[i]+4,IA[i]-4),c(q.d[i,2],q.d[i,2],q.d[i,4],q.d[i,4]),col="light grey")
	
	#median
	segments(IA[i]-4,q.d[i,3],IA[i]+4,q.d[i,3])
}

for(i in 10:11){
	
	#whiskers
	#95%
	segments(IA[i]-4,q.d[i,5],IA[i]+4,q.d[i,5])
	segments(IA[i],q.d[i,4],IA[i],q.d[i,5])
	
	#5%
	segments(IA[i]-4,q.d[i,1],IA[i]+4,q.d[i,1])
	segments(IA[i],q.d[i,2],IA[i],q.d[i,1])
	
	
	#boxplot
	polygon(c(IA[i]-4,IA[i]+4,IA[i]+4,IA[i]-4),c(q.d[i,2],q.d[i,2],q.d[i,4],q.d[i,4]),col="black")
	
	#median
	segments(IA[i]-4,q.d[i,3],IA[i]+4,q.d[i,3])
}

for(i in 12:12){
	
	#whiskers
	#95%
	segments(IA[i]-4,q.d[i,5],IA[i]+4,q.d[i,5])
	segments(IA[i],q.d[i,4],IA[i],q.d[i,5])
	
	#5%
	segments(IA[i]-4,q.d[i,1],IA[i]+4,q.d[i,1])
	segments(IA[i],q.d[i,2],IA[i],q.d[i,1])
	
	
	#boxplot
	polygon(c(IA[i]-4,IA[i]+4,IA[i]+4,IA[i]-4),c(q.d[i,2],q.d[i,2],q.d[i,4],q.d[i,4]),col="dodgerblue")
	
	#median
	segments(IA[i]-4,q.d[i,3],IA[i]+4,q.d[i,3])
}

for(i in 13:13){
	
	#whiskers
	#95%
	segments(IA[i]-4,q.d[i,5],IA[i]+4,q.d[i,5])
	segments(IA[i],q.d[i,4],IA[i],q.d[i,5])
	
	#5%
	segments(IA[i]-4,q.d[i,1],IA[i]+4,q.d[i,1])
	segments(IA[i],q.d[i,2],IA[i],q.d[i,1])
	
	
	#boxplot
	polygon(c(IA[i]-4,IA[i]+4,IA[i]+4,IA[i]-4),c(q.d[i,2],q.d[i,2],q.d[i,4],q.d[i,4]),col="black")
	
	#median
	segments(IA[i]-4,q.d[i,3],IA[i]+4,q.d[i,3])
}
dev.off()

tcalib<-xtable(x=d_fake_q,label="tcalib",caption=c("Densités prédites pour un nombre de tacons 0+ capturé en 5 minutes"))

o<-print(tcalib, file = str_c(tabwd,"tcalib.tex"), 
		table.placement = "h",#indique comment positionner la table
		caption.placement = "top",
		NA.string = ".",
		include.rownames=TRUE,
		tabular.environment="tabularx",
		width="\\textwidth")

write.table(d_fake_q, str_c(tabwd,"d_predict.txt")) #enregistre avec les tableaux, il faudra le mettre en page dans excel puis l'enregistrer en pdf pour l'inclure dans les annexes
}
@
<<calib2, echo=FALSE, eval=TRUE, results=hide>>=
if (chunk_true==1){
	pdf(file=str_c(imgwd,"RelationCalibration2_2015_10_07.pdf"),width=5,height=5)
	plot(1,1,type="n",axes=FALSE,xlim=c(0,300),xlab="Nombre de tacons 0+ pêchés en 5 minutes (IA)",ylim=c(0,1.2),ylab="densité (0+ / m-2)",main="")
	
# trace l'axe des ordonnées
	axis(2,at = seq(0,1.2,0.2),cex.axis = 0.8,las = 1,col = "black")
# trace l'axe des abscisses
	axis(1,at = seq(0,300,25),cex.axis = 0.8,las = 1,col = "black")
	
	points(IA_fake,d_fake_q[,3],type="l",col="red",lwd=1.5)
	points(IA_fake,d_fake_q[,1],type="l",col="red",lwd=1.5,lty=2)
	points(IA_fake,d_fake_q[,5],type="l",col="red",lwd=1.5,lty=2)
		
	for(i in 1:13){
		
		#whiskers
		#95%
		segments(IA[i]-4,q.d[i,5],IA[i]+4,q.d[i,5])
		segments(IA[i],q.d[i,4],IA[i],q.d[i,5])
		
		#5%
		segments(IA[i]-4,q.d[i,1],IA[i]+4,q.d[i,1])
		segments(IA[i],q.d[i,2],IA[i],q.d[i,1])
		
		
		#boxplot
		polygon(c(IA[i]-4,IA[i]+4,IA[i]+4,IA[i]-4),c(q.d[i,2],q.d[i,2],q.d[i,4],q.d[i,4]),col="light grey")
		
		#median
		segments(IA[i]-4,q.d[i,3],IA[i]+4,q.d[i,3])
	}
	
	
	dev.off()
}	
@
Le détail des résultats sur les 13 sites échantillonnés sur le double protocole pêche en 5 minutes et pêche par enlèvement successif est présenté dans le tableau \ref{calib}, 
et la nouvelle relation de calibration à la
figure \ref{relation_calib2}. Le tableau de conversion des indices tacons 0+ en
5 minutes en densité est présenté à l'Annexe \ref{Annexe3}.
Parmi les 4 points échantillonnés en 2015, deux sites présentaient des abondances moyennes : l'un
sur l'Allier (Vabres) et l'autre sur l'Alagnon (Pont de Brugeilles). La relation
entre le nombre de 0+ pêchés et la densité de tacons présents pour ces deux
sites a tendance à être supérieure aux autres sites, mais nous observons que
le point réalisé dans l'Alagnon entre dans la gamme de la relation attendue
(même si le point est situé dans la gamme supérieure de cette relation).
Par rapport à la relation antérieure, ces 4 nouveaux points (et en particulier
la station de Vabres) ont tendance à nous donner une vision un peu plus
optimiste de la densité de tacons 0+ pour un indice d'abondance donné (figure \ref{relation_calib}). Il est à noter que suite
à une panne de matériel intervenue quelques temps avant cette opération, les pêches en 5 minutes réalisées juste avant la pêche par
enlèvement successif ont été réalisées en 2015 à l'aide d'un Volta\textregistered (imeo), alors qu'elles avaient été réalisées jusque là
à l'aide d'un martin pêcheur\textregistered (Dream Electronique).
Une autre campagne de pêche est d'ores et déjà prévue pour l'automne 2016 avec
la réalisation de 4 nouvelles pêches sur le double protocole pêche IA - pêche
complète. Ces nouveaux points viendront ainsi compléter les 13 points déjà
réalisés afin de renforcer la robustesse de cette relation.



\Floatbarrier



\subsection{Répartition des adultes dans les différents secteurs}
<<Repartition_adultes, echo=FALSE, eval=TRUE,results=hide>>=
#je créé un save.image à partir du script figures_modèle_VF.R afin de ne réintégrer que le load 
#(ça évite de pourrir mon rapport rnw) afin de générer le pdf dans sweave (sinon il ne gère pas les accents)
if(chunk_true==1){
	
load(file = "C:/Users/logrami/workspace/ModeleDynamiquePop/script/lateX/data/SpawnersRedds_GeniteursPotentiels_2016.03.07.RData")

#Graph with all years
surf=c(rep(c(916866,250441,0),11),rep(c(916866,250441,301101),12),rep(c(916866,250441,383049),6),rep(c(1202540,250441,383049),(T-29)))
S_juv_JP<-matrix(surf,nrow=3)	

pdf(file=str_c(imgwd,"SpawnersRedds_GeniteursPotentiels_2016_03_07.pdf"))
par(mfrow=c(3,2),mar=c(4,6.1,2,0.5),cex.lab=1.2,col.lab="grey25",col.axis="grey55",col.main="grey25")
#........
# Vichy
#........
plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(0,6000),ylab=expression(italic(S["t,1"])),main="Vichy-Langeac",cex.main=1.5,cex.lab=1.2)
# trace l'axe des ordonnées
axis(2,at = c(0,1000,2000,3000,4000,5000,6000),labels=c(0,1000,2000,3000,4000,5000,6000),cex.axis = 1.2,las = 1,col = "grey55")
# trace l'axe des abscisses
axis(1,at = c(1,6,16,26,T),
		labels=c(1975,1980,1990,2000,(T+1974)),
		cex.axis = 1.5,las = 1,col = "grey55")
text(T,6000,labels=expression(italic("a.")),col = "grey55")
for(i in 3:T){
	#whiskers
	#95%
	segments(i-0.15,S_vichy_q[i,5],i+0.15,S_vichy_q[i,5])
	segments(i,S_vichy_q[i,4],i,S_vichy_q[i,5])
	#5%
	segments(i-0.15,S_vichy_q[i,1],i+0.15,S_vichy_q[i,1])
	segments(i,S_vichy_q[i,2],i,S_vichy_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(S_vichy_q[i,2],S_vichy_q[i,2],S_vichy_q[i,4],S_vichy_q[i,4]),col="coral3")
	#median
	segments(i-0.3,S_vichy_q[i,3],i+0.3,S_vichy_q[i,3])
}
plot(1,1,type="n",axes=FALSE, xlim=c(0.5,T+0.5), xlab="Années", ylim=c(0,1), ylab=expression(italic("ratio Géniteurs")) ,main="Vichy-Langeac",cex.main=1.5,cex.lab=1.2)
# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 1.2,las = 1,col = "grey55")
# trace l'axe des abscisses
axis(1,at = c(1,6,16,26,T),
		labels=c(1975,1980,1990,2000,(T+1974)),
		cex.axis = 1.5,las = 1,col = "grey55")
text(T,1,labels=expression(italic("d.")),col = "grey55")
for(i in 3:T){
	#whiskers
	#95%
	segments(i-0.15,ratio_S_V_q[i,5],i+0.15,ratio_S_V_q[i,5])
	segments(i,ratio_S_V_q[i,4],i,ratio_S_V_q[i,5])
	#5%
	segments(i-0.15,ratio_S_V_q[i,1],i+0.15,ratio_S_V_q[i,1])
	segments(i,ratio_S_V_q[i,2],i,ratio_S_V_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(ratio_S_V_q[i,2],ratio_S_V_q[i,2],ratio_S_V_q[i,4],ratio_S_V_q[i,4]),col="coral3")
	#median
	segments(i-0.3,ratio_S_V_q[i,3],i+0.3,ratio_S_V_q[i,3])
}
segments(0,S_juv_JP[1,1]/(S_juv_JP[1,1]+S_juv_JP[2,1]),11.5,S_juv_JP[1,1]/(S_juv_JP[1,1]+S_juv_JP[2,1]),col="grey35",lty=2,lwd=1)
segments(11.5,S_juv_JP[1,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),23.5,S_juv_JP[1,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),col="grey35",lty=2,lwd=1)
segments(23.5,S_juv_JP[1,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),29.5,S_juv_JP[1,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),col="grey35",lty=2,lwd=1)
segments(29.5,S_juv_JP[1,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),(T+0.5),S_juv_JP[1,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),col="grey35",lty=2,lwd=1)

abline(v=11.5,lty=3)
#..........
# Langeac
#..........
plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(0,1200),ylab=expression(italic(S["t,2"])),main="Langeac-Poutes",cex.main=1.5,cex.lab=1.2)
# trace l'axe des ordonnées
axis(2,at = c(0,300,600,900,1200),labels=c(0,300,600,900,1200),cex.axis = 1.2,las = 1,col = "grey55")
# trace l'axe des abscisses
axis(1,at = c(1,6,16,26,T),
		labels=c(1975,1980,1990,2000,(T+1974)),
		cex.axis = 1.5,las = 1,col = "grey55")
text(T,1200,labels=expression(italic("b.")),col = "grey55")
for(i in 3:T){
	#whiskers
	#95%
	segments(i-0.15,S_langeac_q[i,5],i+0.15,S_langeac_q[i,5])
	segments(i,S_langeac_q[i,4],i,S_langeac_q[i,5])
	#5%
	segments(i-0.15,S_langeac_q[i,1],i+0.15,S_langeac_q[i,1])
	segments(i,S_langeac_q[i,2],i,S_langeac_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(S_langeac_q[i,2],S_langeac_q[i,2],S_langeac_q[i,4],S_langeac_q[i,4]),col="coral3")
	#median
	segments(i-0.3,S_langeac_q[i,3],i+0.3,S_langeac_q[i,3])
}
plot(1,1,type="n",axes=FALSE, xlim=c(0.5,T+0.5), xlab="Années", ylim=c(0,1), ylab=expression(italic("ratio Géniteurs")) ,main="Langeac-Poutes",cex.main=1.5,cex.lab=1.2)
# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 1.2,las = 1,col = "grey55")
# trace l'axe des abscisses
axis(1,at = c(1,6,16,26,T),
		labels=c(1975,1980,1990,2000,(T+1974)),
		cex.axis =1.5,las = 1,col = "grey55")
text(T,1,labels=expression(italic("e.")),col = "grey55")
for(i in 3:T){
	#whiskers
	#95%
	segments(i-0.15,ratio_S_L_q[i,5],i+0.15,ratio_S_L_q[i,5])
	segments(i,ratio_S_L_q[i,4],i,ratio_S_L_q[i,5])
	#5%
	segments(i-0.15,ratio_S_L_q[i,1],i+0.15,ratio_S_L_q[i,1])
	segments(i,ratio_S_L_q[i,2],i,ratio_S_L_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(ratio_S_L_q[i,2],ratio_S_L_q[i,2],ratio_S_L_q[i,4],ratio_S_L_q[i,4]),col="coral3")
	#median
	segments(i-0.3,ratio_S_L_q[i,3],i+0.3,ratio_S_L_q[i,3])
}
segments(0,S_juv_JP[2,1]/(S_juv_JP[1,1]+S_juv_JP[2,1]),11.5,S_juv_JP[2,1]/(S_juv_JP[1,1]+S_juv_JP[2,1]),col="grey35",lty=2,lwd=1)
segments(11.5,S_juv_JP[2,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),23.5,S_juv_JP[2,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),col="grey35",lty=2,lwd=1)
segments(23.5,S_juv_JP[2,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),29.5,S_juv_JP[2,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),col="grey35",lty=2,lwd=1)
segments(29.5,S_juv_JP[2,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),(T+0.5),S_juv_JP[2,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),col="grey35",lty=2,lwd=1)

abline(v=11.5,lty=3)
#..........
# Poutes
#..........
plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(0,200),ylab=expression(italic(S["t,3"])),main="Amont de Poutes",cex.main=1.5,cex.lab=1.2)
# trace l'axe des ordonnées
axis(2,at = c(0,100,200),labels=c(0,100,200),cex.axis = 1.2,las = 1,col = "grey55")
# trace l'axe des abscisses
axis(1,at = c(1,6,16,26,T),
		labels=c(1975,1980,1990,2000,(T+1974)),
		cex.axis = 1.5,las = 1,col = "grey55")
points(x=seq(12,T,1),y=S_poutes_counter[12:T],pch=16,col="darkolivegreen3") 
abline(v=11.5,lty=2)
text(6,100,paste( "Amont Poutes\n inaccessible"),col = "grey55")
text(T,200,labels=expression(italic("c.")),col = "grey55")
plot(1,1,type="n",axes=FALSE, xlim=c(0.5,T+0.5), xlab="Années", ylim=c(0,1), ylab=expression(italic("ratio Géniteurs")) ,main="Amont de Poutes",cex.main=1.5,cex.lab=1.2)
# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis =1.2,las = 1,col = "grey55")
# trace l'axe des abscisses
axis(1,at = c(1,6,16,26,T),
		labels=c(1975,1980,1990,2000,(T+1974)),
		cex.axis =1.5,las = 1,col = "grey55")
text(T,1,labels=expression(italic("f.")),col = "grey55")
text(6,0.55,paste( "Amont Poutes\n inaccessible"),col = "grey55")
for(i in 12:22){
	#whiskers
	#95%
	segments(i-0.15,ratio_S_P_q[i,5],i+0.15,ratio_S_P_q[i,5])
	segments(i,ratio_S_P_q[i,4],i,ratio_S_P_q[i,5])
	#5%
	segments(i-0.15,ratio_S_P_q[i,1],i+0.15,ratio_S_P_q[i,1])
	segments(i,ratio_S_P_q[i,2],i,ratio_S_P_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(ratio_S_P_q[i,2],ratio_S_P_q[i,2],ratio_S_P_q[i,4],ratio_S_P_q[i,4]),col="darkolivegreen3")
	#median
	segments(i-0.3,ratio_S_P_q[i,3],i+0.3,ratio_S_P_q[i,3])
}
x=seq(23,T,1)
points(x,ratio_S_P_q[23:T,3],pch=16,col="darkolivegreen3")
segments(11.5,S_juv_JP[3,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),23.5,S_juv_JP[3,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),col="grey35",lty=2,lwd=1)
segments(23.5,S_juv_JP[3,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),29.5,S_juv_JP[3,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),col="grey35",lty=2,lwd=1)
segments(29.5,S_juv_JP[3,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),(T+0.5),S_juv_JP[3,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),col="grey35",lty=2,lwd=1)
abline(v=11.5,lty=3)
dev.off()

}
@





\FloatBarrier


\subsection{Relation entre nombre d'adultes potentiels et comptages frayères}
<<Relation_adultes_comptages, echo=FALSE, eval=TRUE,results=hide>>=
#je créé un save.image à partir du script figures_modèle_VF.R afin de ne réintégrer que le load 
#(ça évite de pourrir mon rapport rnw) afin de générer le pdf dans sweave (sinon il ne gère pas les accents)
if (chunk_true==1){
load(file = "C:/Users/logrami/workspace/ModeleDynamiquePop/script/lateX/data/Redds_kappa_2016.03.07.RData")

###########################
#plot zone_effect /kappa
###############################
pdf(file=str_c(imgwd,"Redds_kappa_2016_03_07.pdf"))#,width=800, height=800, units = "px",type="cairo"
par(mfrow=c(3,1),mar=c(4,6.1,2,0.5),cex.lab=1.4, cex.lab=1.4,col.lab="grey25",col.axis="grey55",col.main="grey25")
plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(0,3),ylab=expression(italic( kappa["t,1"])),main="Vichy-Langeac")
# trace l'axe des ordonnées
axis(2,at = c(0,1,2,3),labels=c(0,1,2,3),cex.axis = 0.9,las = 1,col = "grey55")
# trace l'axe des abscisses
axis(1,at = c(T-T+1,T-T+1+5,T-T+1+15,T-T+1+25,T-T+1+35,T),
		labels=c(1975,1980,1990,2000,2010,(T+1974)),
		cex.axis = 0.9,las = 1,col = "grey55")
text(T,3,labels=expression(italic("a.")),col = "grey55")
xx=c(0:(T+1),(T+1):0)
q_2_5=rep(mu_zone_q[1,1],(T+2))
q_97_5=rep(mu_zone_q[1,5],(T+2))
yy=c(q_2_5,rev(q_97_5))
polygon(xx,yy,col="rosybrown1",border="NA")
q_25=rep(mu_zone_q[1,2],(T+2))
q_75=rep(mu_zone_q[1,4],(T+2))
yy=c(q_25,rev(q_75))
polygon(xx,yy,col="rosybrown3",border="NA")
points(x=seq(0,(T+1),1),y=rep(mu_zone_q[1,3],(T+2)),type="l",col="white")
for(i in 1:T){
	#whiskers
	#95%
	segments(i-0.15,zone_effect_V_q[i,5],i+0.15,zone_effect_V_q[i,5])
	segments(i,zone_effect_V_q[i,4],i,zone_effect_V_q[i,5])
	#5%
	segments(i-0.15,zone_effect_V_q[i,1],i+0.15,zone_effect_V_q[i,1])
	segments(i,zone_effect_V_q[i,2],i,zone_effect_V_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(zone_effect_V_q[i,2],zone_effect_V_q[i,2],zone_effect_V_q[i,4],zone_effect_V_q[i,4]),col="coral3")
	#median
	segments(i-0.3,zone_effect_V_q[i,3],i+0.3,zone_effect_V_q[i,3])
}
#####################
#####################
plot(1,1,type="n",axes=FALSE,xlim=c(0.5,(T+0.5)),xlab="Années",ylim=c(0,3),ylab=expression(italic(kappa["t,2"])),main="Langeac-Poutes")
# trace l'axe des ordonnées
axis(2,at = c(0,1,2,3),labels=c(0,1,2,3),cex.axis = 0.9,las = 1,col = "grey55")
# trace l'axe des abscisses
axis(1,at = c(T-T+1,T-T+1+5,T-T+1+15,T-T+1+25,T-T+1+35,T),
		labels=c(1975,1980,1990,2000,2010,(T+1974)),
		cex.axis = 0.9,las = 1,col = "grey55")
text(T,3,labels=expression(italic("b.")),col = "grey55")
xx=c(0:(T+1),(T+1):0)
q_2_5=rep(mu_zone_q[1,1],T+2)
q_97_5=rep(mu_zone_q[1,5],T+2)
yy=c(q_2_5,rev(q_97_5))
polygon(xx,yy,col="rosybrown1",border="NA")
q_25=rep(mu_zone_q[1,2],T+2)
q_75=rep(mu_zone_q[1,4],T+2)
yy=c(q_25,rev(q_75))
polygon(xx,yy,col="rosybrown3",border="NA")
points(x=seq(0,T+1,1),y=rep(mu_zone_q[1,3],T+2),type="l",col="white")
for(i in 1:T){
	#whiskers
	#95%
	segments(i-0.15,zone_effect_L_q[i,5],i+0.15,zone_effect_L_q[i,5])
	segments(i,zone_effect_L_q[i,4],i,zone_effect_L_q[i,5])
	#5%
	segments(i-0.15,zone_effect_L_q[i,1],i+0.15,zone_effect_L_q[i,1])
	segments(i,zone_effect_L_q[i,2],i,zone_effect_L_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(zone_effect_L_q[i,2],zone_effect_L_q[i,2],zone_effect_L_q[i,4],zone_effect_L_q[i,4]),col="coral3")
	#median
	segments(i-0.3,zone_effect_L_q[i,3],i+0.3,zone_effect_L_q[i,3])
}
#####################
#####################
plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(0,6),ylab=expression(italic(kappa["t,3"])),main="Amont de Poutes")
# trace l'axe des ordonnées
axis(2,at = c(0,1,2,3,4,5,6),labels=c(0,1,2,3,4,5,6),cex.axis = 0.9,las = 1,col = "grey55")
# trace l'axe des abscisses
axis(1,at = c(T-T+1,T-T+1+5,T-T+1+15,T-T+1+25,T-T+1+35,T),
		labels=c(1975,1980,1990,2000,2010,(T+1974)),
		cex.axis = 0.9,las = 1,col = "grey55")
text(T,6,labels=expression(italic("c.")),col = "grey55")
points(seq(11.5,T+1,0.5),rep(1,(T-10)*2),type="l",col="palegreen4")
for(i in 12:T){
	#whiskers
	#95%
	segments(i-0.15,zone_effect_P_q[i,5],i+0.15,zone_effect_P_q[i,5])
	segments(i,zone_effect_P_q[i,4],i,zone_effect_P_q[i,5])
	#5%
	segments(i-0.15,zone_effect_P_q[i,1],i+0.15,zone_effect_P_q[i,1])
	segments(i,zone_effect_P_q[i,2],i,zone_effect_P_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(zone_effect_P_q[i,2],zone_effect_P_q[i,2],zone_effect_P_q[i,4],zone_effect_P_q[i,4]),col="darkolivegreen3")
	#median
	segments(i-0.3,zone_effect_P_q[i,3],i+0.3,zone_effect_P_q[i,3])
}
abline(v=11.5,lty=2)
text(4,3,paste( "Amont de Poutes\n inaccessible"))
dev.off()

}
@




\FloatBarrier

\subsection{Relations de recrutement densité--dépendant}
<<relation_DD, echo=FALSE, eval=TRUE, results=hide>>=
if (chunk_true==1){
	
#je créé un save.image à partir du script figures_modèle_VF.R afin de ne réintégrer que le load 
#(ça évite de pourrir mon rapport rnw) afin de générer le pdf dans sweave (sinon il ne gère pas les accents)
load(file = "C:/Users/logrami/workspace/ModeleDynamiquePop/script/lateX/data/dd_2016.03.08.RData")

pdf(file=str_c(imgwd,"dd_2016_03_08.pdf"))#,width=800,height=800)
par(mfrow=c(2,1),mar=c(4,5.5,2,1.5))
#Graphe densite dependence juvenile sauvage
plot(1,1,type="n",axes=FALSE,xlim=c(0,0.0025),xlab=expression(paste(S," ",(géniteurs.m^-2))),ylim=c(0,0.35),ylab=expression(paste(d^sauvage," (0+",.m^-2,")")),main="relation de densité dépendance des 0+ sauvages",cex.main=1.5,cex.lab=1.2)
# trace l'axe des ordonnées
axis(1,at = c(0,0.00050,0.0010,0.0015, 0.002, 0.0025),
		labels=c(0,expression(paste(0.5," x ",10^-3)),expression(10^-3),expression(paste(1.5," x ",10^-3)),expression(paste(2," x ",10^-3)),expression(paste(2.5," x ",10^-3)) ),
		cex.axis = 1.2,las = 1,lwd=2)
# trace l'axe des abscisses
axis(2,at = c(0,0.05,0.10,0.15,0.20,0.25,0.30,0.35),
		labels=c(0,0.05,0.10,0.15,0.20,0.25,0.30,0.35),
		cex.axis = 1.2,las = 1,lwd=2)
points(S_vichy_q[1:(T-1),3]/S_juv_JP[1,1:(T-1)],dmoy_wild_V_q[2:T,3],pch=16,col="coral3")#"gray15")
points(S_langeac_q[1:(T-1),3]/S_juv_JP[2,1:(T-1)],dmoy_wild_L_q[2:T,3],pch=16,col="darkolivegreen4")#"gray45")
points(S_poutes_counter[12:(T-1)]/S_juv_JP[3,12:(T-1)],dmoy_wild_P_q[13:T,3],pch=16,col="darkolivegreen3")#"gray75")
x=seq(0,0.0025,0.0000001)
y=exp(log(x/(1/median(a) + x * 1/median(Rmax))) + median(nu_wild[,1]))
points(x,y,type="l",col="coral3")#"gray15")
y=exp(log(x/(1/median(a) + x * 1/median(Rmax))) + median(nu_wild[,2]))
points(x,y,type="l",col="darkolivegreen4")#"gray45")
text(0.0025,0.35,labels=expression(italic("a.")),col = "grey55",cex=1.5)

#Graphe densite dependence juvenile repeuplement
plot(1,1,type="n",axes=FALSE,xlim=c(0,1.4),xlab=expression(paste(Stock^juv," ",(0+.m^-2))),ylim=c(0,0.35),ylab=expression(paste(d^juv," (0+",.m^-2,")")),main="relation de densité dépendance des 0+ repeuplés",cex.main=1.5,cex.lab=1.2)
# trace l'axe des abcisses
axis(1,at = c(0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1,1.1,1.2,1.3,1.4),
		labels=c(0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1,1.1,1.2,1.3,1.4),
		cex.axis = 1.2,las = 1)
# trace l'axe des ordonnées
axis(2,at = c(0,0.05,0.10,0.15,0.2,0.25,0.3,0.35),
		labels=c(0,0.05,0.10,0.15,0.20,0.25,0.3,0.35),
		cex.axis = 1.2,las = 1)
points(stocked_juv_V_d[I_juv_V],dmoy_juv_V_q[I_juv_V,3],pch=15,col="coral3")
points(stocked_juv_L_d[I_juv_L],dmoy_juv_L_q[I_juv_L,3],pch=15,col="darkolivegreen4")
points(stocked_juv_P_d[I_juv_P],dmoy_juv_P_q[I_juv_P,3],pch=15,col="darkolivegreen3")
#x=seq(0,0.35,0.0001)
points(x,x,type="l",lty=2,col="grey15")
x=seq(0,1.4,0.0001)
y=  x / ( ( 1 / exp(median(nu_wild[,1]))) * 1/median(a_juv) + x * 1/median(Rmax)  )   
points(x,y,type="l",col="coral3")
y=  x / ( ( 1 / exp(median(nu_wild[,2]))) * 1/median(a_juv) + x * 1/median(Rmax)  )   
points(x,y,type="l",col="darkolivegreen4")
text(1.4,0.35,labels=expression(italic("b.")),col = "grey55",cex=1.5)
#legend(0,0.2,bg="white",legend=c("Vichy-Langeac","Langeac-Poutes","upstream Poutes","downstream Langeac","upstream Langeac"),lty=c(NA,NA,NA,1,1),pch=c(15,15,15,NA,NA),col=c("gray15","gray45","gray75","gray15","gray75"))
dev.off()

}
@


\FloatBarrier

\subsection{Répartition des juvéniles dans les secteurs et relation entre la
répartition des géniteurs et celle des juvéniles}

<<juv_prod_geni, echo=FALSE, eval=TRUE, results=hide>>=

if (chunk_true==1){
	
#Recopié du script figures_model_VF
	load("C:/Users/logrami/workspace/ModeleDynamiquePop/script/lateX/data/JuvProdRatioGeni_2016.03.08.RData")
	
	pdf(file=str_c(imgwd,"JuvProdRatioGeni_2016_03_08.pdf"))
	par(mfrow=c(3,3),mar=c(4,6.1,2,0.5),cex.lab=1.4, cex.lab=1.4,col.lab="grey25",col.axis="grey55",col.main="grey25")
	
	surf=c(rep(c(916866,250441,0),11),rep(c(916866,250441,301101),12),rep(c(916866,250441,383049),6),rep(c(1202540,250441,383049),(T-29)))
	S_juv_JP<-matrix(surf,nrow=3)
	#----------
	# Vichy
	#---------
	#.................
	# Prod juveniles
	#.................
	plot(1,1,type="n",axes=FALSE, xlim=c(0.5,T+0.5), xlab="Années", ylim=c(0,1), ylab=expression(italic("ratio prod. juvénile")) ,main="Vichy-Langeac",cex.main=1,cex.lab=1)
	
	# trace l'axe des ordonnées
	axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 1,las = 1,col = "grey55")
	# trace l'axe des abscisses
	lab1=c(1976,1980,1990,2000,1974+T)
	axis(1,at = c(1,5,15,25,T),
			labels=lab1,
			cex.axis = 1,las = 1,col = "grey55")
	
	text(T,1,labels=expression(italic("a.")),col = "grey55",cex=1)
	
	for(i in 7:T){
		#whiskers
		#95%
		segments(i-0.15,ratio_juv_tot_V_q[i,5],i+0.15,ratio_juv_tot_V_q[i,5])
		segments(i,ratio_juv_tot_V_q[i,4],i,ratio_juv_tot_V_q[i,5])
		#5%
		segments(i-0.15,ratio_juv_tot_V_q[i,1],i+0.15,ratio_juv_tot_V_q[i,1])
		segments(i,ratio_juv_tot_V_q[i,2],i,ratio_juv_tot_V_q[i,1])
		#boxplot
		polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(ratio_juv_tot_V_q[i,2],ratio_juv_tot_V_q[i,2],ratio_juv_tot_V_q[i,4],ratio_juv_tot_V_q[i,4]),col="coral3")
		#median
		segments(i-0.3,ratio_juv_tot_V_q[i,3],i+0.3,ratio_juv_tot_V_q[i,3])
	}
	
	segments(0,S_juv_JP[1,1]/(S_juv_JP[1,1]+S_juv_JP[2,1]),11.5,S_juv_JP[1,1]/(S_juv_JP[1,1]+S_juv_JP[2,1]),col="grey35",lty=2,lwd=1)
	segments(11.5,S_juv_JP[1,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),23.5,S_juv_JP[1,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),col="grey35",lty=2,lwd=1)
	segments(23.5,S_juv_JP[1,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),29.5,S_juv_JP[1,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),col="grey35",lty=2,lwd=1)
	segments(29.5,S_juv_JP[1,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),(T+0.5),S_juv_JP[1,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),col="grey35",lty=2,lwd=1)
	
	#segments(7,mean(ratio_juv_tot_V[,7:12]),12.5,mean(ratio_juv_tot_V[,7:12]),col="grey25",lty=2,lwd=2)
	#segments(12.5,mean(ratio_juv_tot_V[,13:37]),37.5,mean(ratio_juv_tot_V[,13:37]),col="grey25",lty=2,lwd=2)
	
	abline(v=12.5,lty=3,col = "grey55")
	
	#............
	# Spawners
	#............
	plot(1,1,type="n",axes=FALSE, xlim=c(0.5,T+0.5), xlab="Années", ylim=c(0,1), ylab=expression(italic("ratio géniteurs")) ,main="Vichy-Langeac",cex.main=1,cex.lab=1)
	
	# trace l'axe des ordonnées
	axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 1,las = 1,col = "grey55")
	# trace l'axe des abscisses
	lab1=c(1976,1980,1990,2000,1974+T)
	axis(1,at = c(1,5,15,25,T),
			labels=lab1,
			cex.axis = 1,las = 1,col = "grey55")
	
	text(T,1,labels=expression(italic("b.")),col = "grey55",cex=1)
	
	for(i in 1:T){
		#whiskers
		#95%
		segments(i-0.15,ratio_S_V_q[i,5],i+0.15,ratio_S_V_q[i,5])
		segments(i,ratio_S_V_q[i,4],i,ratio_S_V_q[i,5])
		#5%
		segments(i-0.15,ratio_S_V_q[i,1],i+0.15,ratio_S_V_q[i,1])
		segments(i,ratio_S_V_q[i,2],i,ratio_S_V_q[i,1])
		#boxplot
		polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(ratio_S_V_q[i,2],ratio_S_V_q[i,2],ratio_S_V_q[i,4],ratio_S_V_q[i,4]),col="coral3")
		#median
		segments(i-0.3,ratio_S_V_q[i,3],i+0.3,ratio_S_V_q[i,3])
	}
	
	segments(0,S_juv_JP[1,1]/(S_juv_JP[1,1]+S_juv_JP[2,1]),11.5,S_juv_JP[1,1]/(S_juv_JP[1,1]+S_juv_JP[2,1]),col="grey35",lty=2,lwd=1)
	segments(11.5,S_juv_JP[1,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),23.5,S_juv_JP[1,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),col="grey35",lty=2,lwd=1)
	segments(23.5,S_juv_JP[1,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),29.5,S_juv_JP[1,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),col="grey35",lty=2,lwd=1)
	segments(29.5,S_juv_JP[1,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),(T+0.5),S_juv_JP[1,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),col="grey35",lty=2,lwd=1)
	
	
	#segments(0,mean(ratio_S_V[,1:12]),12.5,mean(ratio_S_V[,1:12]),col="grey25",lty=2,lwd=2)
	#segments(12.5,mean(ratio_S_V[,13:37]),37.5,mean(ratio_S_V[,13:37]),col="grey25",lty=2,lwd=2)
	
	abline(v=12.5,lty=3,col = "grey55")
	
	#............. 
	# diff ratio
	#.............
	plot(1,1,type="n",axes=FALSE, xlim=c(0.5,T+0.5), xlab="Années", ylim=c(-0.5,0.5), ylab=expression(italic("diff. ratio géniteur - ratio juv.")) ,main="Vichy-Langeac",cex.main=1,cex.lab=1)
	
	# trace l'axe des ordonnées
	axis(2,at = c(-0.5,-0.25,0,0.25,0.5),labels=c(-0.5,-0.25,0,0.25,0.5),cex.axis = 1,las = 1,col = "grey55")
	# trace l'axe des abscisses
	lab1=c(1976,1980,1990,2000,1974+T)
	axis(1,at = c(1,5,15,25,T),
			labels=lab1,
			cex.axis = 1,las = 1,col = "grey55")
	
	text(T,0.5,labels=expression(italic("c.")),col = "grey55",cex=1)
	
	for(i in 7:T){
		#whiskers
		#95%
		segments(i-0.15,diff_ratio_V_q[i,5],i+0.15,diff_ratio_V_q[i,5])
		segments(i,diff_ratio_V_q[i,4],i,diff_ratio_V_q[i,5])
		#5%
		segments(i-0.15,diff_ratio_V_q[i,1],i+0.15,diff_ratio_V_q[i,1])
		segments(i,diff_ratio_V_q[i,2],i,diff_ratio_V_q[i,1])
		#boxplot
		polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(diff_ratio_V_q[i,2],diff_ratio_V_q[i,2],diff_ratio_V_q[i,4],diff_ratio_V_q[i,4]),col="coral3")
		#median
		segments(i-0.3,diff_ratio_V_q[i,3],i+0.3,diff_ratio_V_q[i,3])
	}
	
	abline(h=0,lty=2,col = "grey55")
	abline(v=12.5,lty=3,col = "grey55")
	
	#----------
	# Langeac
	#---------
	#...................
	# Prod juveniles
	#...................
	plot(1,1,type="n",axes=FALSE, xlim=c(0.5,T+0.5), xlab="Années", ylim=c(0,1), ylab=expression(italic("ratio prod. juvénile")) ,main="Langeac-Poutes",cex.main=1,cex.lab=1)
	
	# trace l'axe des ordonnées
	axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 1,las = 1,col = "grey55")
	# trace l'axe des abscisses
	lab1=c(1976,1980,1990,2000,1974+T)
	axis(1,at = c(1,5,15,25,T),
			labels=lab1,
			cex.axis = 1,las = 1,col = "grey55")
	
	text(T,1,labels=expression(italic("d.")),col = "grey55",cex=1)
	
	for(i in 7:T){
		#whiskers
		#95%
		segments(i-0.15,ratio_juv_tot_L_q[i,5],i+0.15,ratio_juv_tot_L_q[i,5])
		segments(i,ratio_juv_tot_L_q[i,4],i,ratio_juv_tot_L_q[i,5])
		#5%
		segments(i-0.15,ratio_juv_tot_L_q[i,1],i+0.15,ratio_juv_tot_L_q[i,1])
		segments(i,ratio_juv_tot_L_q[i,2],i,ratio_juv_tot_L_q[i,1])
		#boxplot
		polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(ratio_juv_tot_L_q[i,2],ratio_juv_tot_L_q[i,2],ratio_juv_tot_L_q[i,4],ratio_juv_tot_L_q[i,4]),col="darkolivegreen4")
		#median
		segments(i-0.3,ratio_juv_tot_L_q[i,3],i+0.3,ratio_juv_tot_L_q[i,3])
	}
	
	
	segments(0,S_juv_JP[2,1]/(S_juv_JP[1,1]+S_juv_JP[2,1]),11.5,S_juv_JP[2,1]/(S_juv_JP[1,1]+S_juv_JP[2,1]),col="grey35",lty=2,lwd=1)
	segments(11.5,S_juv_JP[2,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),23.5,S_juv_JP[2,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),col="grey35",lty=2,lwd=1)
	segments(23.5,S_juv_JP[2,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),29.5,S_juv_JP[2,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),col="grey35",lty=2,lwd=1)
	segments(29.5,S_juv_JP[2,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),(T+0.5),S_juv_JP[2,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),col="grey35",lty=2,lwd=1)
	
	abline(v=12.5,lty=3,col = "grey55")
	
	#............
	# Spawners
	#............
	plot(1,1,type="n",axes=FALSE, xlim=c(0.5,T+0.5), xlab="Années", ylim=c(0,1), ylab=expression(italic("ratio géniteurs")) ,main="Langeac-Poutes",cex.main=1,cex.lab=1)
	
	# trace l'axe des ordonnées
	axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 1,las = 1,col = "grey55")
	# trace l'axe des abscisses
	lab1=c(1976,1980,1990,2000,1974+T)
	axis(1,at = c(1,5,15,25,T),
			labels=lab1,
			cex.axis = 1,las = 1,col = "grey55")
	
	text(T,1,labels=expression(italic("e.")),col = "grey55",cex=1)
	
	for(i in 1:T){
		#whiskers
		#95%
		segments(i-0.15,ratio_S_L_q[i,5],i+0.15,ratio_S_L_q[i,5])
		segments(i,ratio_S_L_q[i,4],i,ratio_S_L_q[i,5])
		#5%
		segments(i-0.15,ratio_S_L_q[i,1],i+0.15,ratio_S_L_q[i,1])
		segments(i,ratio_S_L_q[i,2],i,ratio_S_L_q[i,1])
		#boxplot
		polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(ratio_S_L_q[i,2],ratio_S_L_q[i,2],ratio_S_L_q[i,4],ratio_S_L_q[i,4]),col="darkolivegreen4")
		#median
		segments(i-0.3,ratio_S_L_q[i,3],i+0.3,ratio_S_L_q[i,3])
	}
	
	segments(0,S_juv_JP[2,1]/(S_juv_JP[1,1]+S_juv_JP[2,1]),11.5,S_juv_JP[2,1]/(S_juv_JP[1,1]+S_juv_JP[2,1]),col="grey35",lty=2,lwd=1)
	segments(11.5,S_juv_JP[2,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),23.5,S_juv_JP[2,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),col="grey35",lty=2,lwd=1)
	segments(23.5,S_juv_JP[2,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),29.5,S_juv_JP[2,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),col="grey35",lty=2,lwd=1)
	segments(29.5,S_juv_JP[2,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),(T+0.5),S_juv_JP[2,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),col="grey35",lty=2,lwd=1)
	
	#segments(0,mean(ratio_S_L[,1:12]),12.5,mean(ratio_S_L[,1:12]),col="grey25",lty=2,lwd=2)
	#segments(12.5,mean(ratio_S_L[,13:37]),37.5,mean(ratio_S_L[,13:37]),col="grey25",lty=2,lwd=2)
	
	abline(v=12.5,lty=3,col = "grey55")
	
	#..............
	# diff ratio
	#..............
	plot(1,1,type="n",axes=FALSE, xlim=c(0.5,T+0.5), xlab="Années", ylim=c(-0.5,0.5), ylab=expression(italic("diff. ratio géniteur - ratio juv.")) ,main="Langeac-Poutes",cex.main=1,cex.lab=1)
	
	# trace l'axe des ordonnées
	axis(2,at = c(-0.5,-0.25,0,0.25,0.5),labels=c(-0.5,-0.25,0,0.25,0.5),cex.axis = 1,las = 1,col = "grey55")
	# trace l'axe des abscisses
	lab1=c(1976,1980,1990,2000,1974+T)
	axis(1,at = c(1,5,15,25,T),
			labels=lab1,
			cex.axis = 1,las = 1,col = "grey55")
	
	text(T,0.5,labels=expression(italic("f.")),col = "grey55",cex=1)
	
	for(i in 7:T){
		#whiskers
		#95%
		segments(i-0.15,diff_ratio_L_q[i,5],i+0.15,diff_ratio_L_q[i,5])
		segments(i,diff_ratio_L_q[i,4],i,diff_ratio_L_q[i,5])
		#5%
		segments(i-0.15,diff_ratio_L_q[i,1],i+0.15,diff_ratio_L_q[i,1])
		segments(i,diff_ratio_L_q[i,2],i,diff_ratio_L_q[i,1])
		#boxplot
		polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(diff_ratio_L_q[i,2],diff_ratio_L_q[i,2],diff_ratio_L_q[i,4],diff_ratio_L_q[i,4]),col="darkolivegreen4")
		#median
		segments(i-0.3,diff_ratio_L_q[i,3],i+0.3,diff_ratio_L_q[i,3])
	}
	
	abline(h=0,lty=2,col = "grey55")
	abline(v=12.5,lty=3,col = "grey55")
	
	
	#----------
	# Poutes
	#----------
	#.................
	# Prod juveniles
	#.................
	plot(1,1,type="n",axes=FALSE, xlim=c(0.5,T+0.5), xlab="Années", ylim=c(0,1), ylab=expression(italic("ratio prod. juvénile")) ,main="upstream Poutes",cex.main=1,cex.lab=1)
	
	# trace l'axe des ordonnées
	axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 1,las = 1,col = "grey55")
	# trace l'axe des abscisses
	lab1=c(1976,1980,1990,2000,1974+T)
	axis(1,at = c(1,5,15,25,T),
			labels=lab1,
			cex.axis = 1,las = 1,col = "grey55")
	
	text(T,1,labels=expression(italic("g.")),col = "grey55",cex=1)
	
	for(i in 16:T){
		#whiskers
		#95%
		segments(i-0.15,ratio_juv_tot_P_q[i,5],i+0.15,ratio_juv_tot_P_q[i,5])
		segments(i,ratio_juv_tot_P_q[i,4],i,ratio_juv_tot_P_q[i,5])
		#5%
		segments(i-0.15,ratio_juv_tot_P_q[i,1],i+0.15,ratio_juv_tot_P_q[i,1])
		segments(i,ratio_juv_tot_P_q[i,2],i,ratio_juv_tot_P_q[i,1])
		#boxplot
		polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(ratio_juv_tot_P_q[i,2],ratio_juv_tot_P_q[i,2],ratio_juv_tot_P_q[i,4],ratio_juv_tot_P_q[i,4]),col="darkolivegreen3")
		#median
		segments(i-0.3,ratio_juv_tot_P_q[i,3],i+0.3,ratio_juv_tot_P_q[i,3])
	}
	
	points(x=c(13,14,15),y=c(0,0,0),pch=16,col="darkolivegreen3")
	
	segments(11.5,S_juv_JP[3,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),23.5,S_juv_JP[3,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),col="grey35",lty=2,lwd=1)
	segments(23.5,S_juv_JP[3,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),29.5,S_juv_JP[3,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),col="grey35",lty=2,lwd=1)
	segments(29.5,S_juv_JP[3,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),(T+0.5),S_juv_JP[3,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),col="grey35",lty=2,lwd=1)
	
	abline(v=12.5,lty=3,col = "grey55")
	
	#............
	# Spawners
	#............			
	plot(1,1,type="n",axes=FALSE, xlim=c(0.5,T+0.5), xlab="Années", ylim=c(0,1), ylab=expression(italic("ratio géniteurs")) ,main="upstream Poutes",cex.main=1,cex.lab=1)
	
	# trace l'axe des ordonnées
	axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 1,las = 1,col = "grey55")
	# trace l'axe des abscisses
	lab1=c(1976,1980,1990,2000,1974+T)
	axis(1,at = c(1,5,15,25,T),
			labels=lab1,
			cex.axis = 1,las = 1,col = "grey55")
	
	text(T,1,labels=expression(italic("h.")),col = "grey55",cex=1)
	
	for(i in 13:23){
		#whiskers
		#95%
		segments(i-0.15,ratio_S_P_q[i,5],i+0.15,ratio_S_P_q[i,5])
		segments(i,ratio_S_P_q[i,4],i,ratio_S_P_q[i,5])
		#5%
		segments(i-0.15,ratio_S_P_q[i,1],i+0.15,ratio_S_P_q[i,1])
		segments(i,ratio_S_P_q[i,2],i,ratio_S_P_q[i,1])
		#boxplot
		polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(ratio_S_P_q[i,2],ratio_S_P_q[i,2],ratio_S_P_q[i,4],ratio_S_P_q[i,4]),col="darkolivegreen3")
		#median
		segments(i-0.3,ratio_S_P_q[i,3],i+0.3,ratio_S_P_q[i,3])
	}
	
	x=seq(24,T,1)
	points(x,ratio_S_P_q[24:T,3],pch=16,col="darkolivegreen3")
	
	segments(11.5,S_juv_JP[3,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),23.5,S_juv_JP[3,12]/(S_juv_JP[1,12]+S_juv_JP[2,12]+S_juv_JP[3,12]),col="grey35",lty=2,lwd=1)
	segments(23.5,S_juv_JP[3,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),29.5,S_juv_JP[3,24]/(S_juv_JP[1,24]+S_juv_JP[2,24]+S_juv_JP[3,24]),col="grey35",lty=2,lwd=1)
	segments(29.5,S_juv_JP[3,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),(T+0.5),S_juv_JP[3,30]/(S_juv_JP[1,30]+S_juv_JP[2,30]+S_juv_JP[3,30]),col="grey35",lty=2,lwd=1)
	
	abline(v=12.5,lty=3,col = "grey55")
	
	#.............. 
	# diff ratio
	#..............
	plot(1,1,type="n",axes=FALSE, xlim=c(0.5,T+0.5), xlab="Années", ylim=c(-0.5,0.5), ylab=expression(italic("diff. ratio géniteur - ratio juv.")) ,main="upstream Poutes",cex.main=1,cex.lab=1)
	
	# trace l'axe des ordonnées
	axis(2,at = c(-0.5,-0.25,0,0.25,0.5),labels=c(-0.5,-0.25,0,0.25,0.5),cex.axis = 1,las = 1,col = "grey55")
	# trace l'axe des abscisses
	lab1=c(1976,1980,1990,2000,1974+T)
	axis(1,at = c(1,5,15,25,T),
			labels=lab1,
			cex.axis = 1,las = 1,col = "grey55")
	
	text(T,0.5,labels=expression(italic("i.")),cex=1)
	
	for(i in 13:T){
		#whiskers
		#95%
		segments(i-0.15,diff_ratio_P_q[i,5],i+0.15,diff_ratio_P_q[i,5])
		segments(i,diff_ratio_P_q[i,4],i,diff_ratio_P_q[i,5])
		#5%
		segments(i-0.15,diff_ratio_P_q[i,1],i+0.15,diff_ratio_P_q[i,1])
		segments(i,diff_ratio_P_q[i,2],i,diff_ratio_P_q[i,1])
		#boxplot
		polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(diff_ratio_P_q[i,2],diff_ratio_P_q[i,2],diff_ratio_P_q[i,4],diff_ratio_P_q[i,4]),col="darkolivegreen3")
		#median
		segments(i-0.3,diff_ratio_P_q[i,3],i+0.3,diff_ratio_P_q[i,3])
	}
	
	abline(h=0,lty=2,col = "grey55")
	abline(v=12.5,lty=3,col = "grey55")
	
	for (i in 1:T){
		S_vichy_q[i,]=quantile(S_vichy_real[,i],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
		S_langeac_q[i,]=quantile(S_langeac_real[,i],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
	}
	
	dev.off()
	
}
@

La figure \ref{Juv_Prod_Ratio} met en avant une réelle rupture dans la
répartition des cohortes de juvéniles à l'origine des retours d'adultes
(J$^{coh}_{t,i}$) \footnote{J$^{coh}_{t,i}$ représente la somme de toutes les
années pour lesquelles la production de juvéniles influence les retours
d'adultes pour une année donnée.
\begin{equation}
  \begin{align}
  J$^{coh}_{t,i}$ = $\frac{1}{3}$ \times J$_{t-3,i}$ + $\frac{1}{3}$ \times J$_{t-4,i}$ + $\frac{1}{3}$ \times J$_{t-5,i}$
  \end{align}
\end{equation} }. Cette rupture correspond à l'instauration de la zone refuge en
2008 \footnote{Après une année de transition (2007) tout déversement au stade alevin a cessé 
en amont de Langeac en 2008. En 2009, la zone refuge 
est créée. Plus aucun déversement à quels que stades que ce soit n'a lieu dans
cette zone (y compris au stade oeuf)}. En effet, la création de cette zone
refuge a conduit à un changement total de la stratégie de déversement, avec dès
2008 un déversement important (qui s'est accentué à partir de 2009) d'alevins
sur le secteur 1 (Vichy-Langeac) (cf. figure \ref{alv_dev}). Ainsi, les
retours d'adultes en 2011 sont issus à 1/3 d'alevins produits en 2008 selon
cette nouvelle stratégie et de 2/3 d'alevins produits selon l'acienne stratégie
(2006 et 2007) ; en 2012 les retours sont issus à 2/3 des juvéniles produits sur
la nouvelle stratégie (2008 et 2009) et à 1/3 sur l'ancienne. A partir des
retours 2013 l'ensemble des juvéniles à l'origine des retours d'adultes sont
issus de cette nouvelle stratégie. La figure \ref{Juv_Prod_Ratio} montre bien que depuis
la mise en place de la zone refuge, une redistribution spatiale de la production de juvéniles a eu lieu au profit de la partie aval (secteur 1). 
Dans le même
temps, la zone en amont de Poutès a vu sa contribution relative à la production de juvéniles diminuer de
façon importante, tandis que le secteur intermédiaire (Langeac-Poutès) ne montre
pas de changement très net.
Si le homing est très strict et qu'il n'y a pas de problème à la montaison
(c'est-à-dire que tous les juvéniles survivant d'un secteur donné reviennent
comme adulte dans ce même secteur) on s'attend à ce que la différence entre le
ratio de géniteurs potentiels et le ratio de juvéniles produits soit en moyenne
proche de 0. Ce n'est pas ce que nous observons (figure \ref{Juv_Prod_Ratio} c,
f et i). En effet, en moyenne le secteur Vichy-Langeac \og reçoit \fg{}



\FloatBarrier  

\subsection{Taux de retour du tacon 0+ et du smolt déversé à l'adulte}
\label{resu_tx_retour}

<<Repartition_adultes, echo=FALSE, eval=TRUE,results=hide>>=

if (chunk_true==1){

#je créé un save.image à partir du script figures_modèle_VF.R afin de ne réintégrer que le load 
#(ça évite de pourrir mon rapport rnw) afin de générer le pdf dans sweave (sinon il ne gère pas les accents)
load(file = "C:/Users/logrami/workspace/ModeleDynamiquePop/script/lateX/data/SurvivalJuv2Ad_2016.03.08.RData")

palette_s=rainbow(15,start=0.1,end=2/6)
palette_s=rev(palette_s)

pdf(file=str_c(imgwd,"SurvivalJuv2Ad_2016_03_08.pdf"))#,width=800, height=800, units = "px",type="cairo")
par(mfrow=c(2,1),mar=c(4,7.1,2,0.5),col.lab="grey25",col.axis="grey55",col.main="grey25")
plot(1,1,type="n",axes=FALSE, xlim=c(0.5,39.5), xlab="Années", ylim=c(0,0.05), ylab="",main="Survie moyenne du 0+ à l'adulte de retour" )
# trace l'axe des ordonnées
axis(2,at = c(0,0.01,0.02,0.03,0.04,0.05),labels=c(0,0.01,0.02,0.03,0.04,0.05),cex.axis = 0.9,las = 1,col = "grey55")
# trace l'axe des abscisses
axis(1,at = c(1,6,16,26,39),
		labels=c(1975,1980,1990,2000,(T+1974)),
		cex.axis = 0.9,las = 1,col = "grey55")
for(i in 7:21){
	#whiskers
	#95%
	segments(i-0.15,s_q[i,5],i+0.15,s_q[i,5])
	segments(i,s_q[i,4],i,s_q[i,5])
	#5%
	segments(i-0.15,s_q[i,1],i+0.15,s_q[i,1])
	segments(i,s_q[i,2],i,s_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(s_q[i,2],s_q[i,2],s_q[i,4],s_q[i,4]),col=palette_s[i-6])
	#median
	segments(i-0.3,s_q[i,3],i+0.3,s_q[i,3])
}
for(i in 22:T){
	#whiskers
	#95%
	segments(i-0.15,s_q[i,5],i+0.15,s_q[i,5])
	segments(i,s_q[i,4],i,s_q[i,5])
	#5%
	segments(i-0.15,s_q[i,1],i+0.15,s_q[i,1])
	segments(i,s_q[i,2],i,s_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(s_q[i,2],s_q[i,2],s_q[i,4],s_q[i,4]),col=palette_s[15])
	#median
	segments(i-0.3,s_q[i,3],i+0.3,s_q[i,3])
}
plot(1,1,type="n",axes=FALSE, xlim=c(0.5,39.5), xlab="Années", ylim=c(0,0.05), ylab="",main="Survie moyenne du smolt déversé à l'adulte de retour" )
# trace l'axe des ordonnées
axis(2,at = c(0,0.01,0.02,0.03,0.04,0.05),labels=c(0,0.01,0.02,0.03,0.04,0.05),cex.axis = 0.9,las = 1,col = "grey55")
# trace l'axe des abscisses
axis(1,at = c(1,6,16,26,39),
		labels=c(1975,1980,1990,2000,(T+1974)),
		cex.axis = 0.9,las = 1,col = "grey55")
for(i in 7:21){
	#whiskers
	#95%
	segments(i-0.15,s_smolt_q[i,5],i+0.15,s_smolt_q[i,5])
	segments(i,s_smolt_q[i,4],i,s_smolt_q[i,5])
	#5%
	segments(i-0.15,s_smolt_q[i,1],i+0.15,s_smolt_q[i,1])
	segments(i,s_smolt_q[i,2],i,s_smolt_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(s_smolt_q[i,2],s_smolt_q[i,2],s_smolt_q[i,4],s_smolt_q[i,4]),col=palette_s[i-6])
	#median
	segments(i-0.3,s_smolt_q[i,3],i+0.3,s_smolt_q[i,3])
}
for(i in 22:T){
	points(i,s_smolt_q[i,3],pch=16,col=palette_s[15])
	#whiskers
	#95%
	#segments(i-0.15,s_smolt_q[i,5],i+0.15,s_smolt_q[i,5])
	#segments(i,s_smolt_q[i,4],i,s_smolt_q[i,5])
	#5%
	#segments(i-0.15,s_smolt_q[i,1],i+0.15,s_smolt_q[i,1])
	#segments(i,s_smolt_q[i,2],i,s_smolt_q[i,1])
	#boxplot
	#polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(s_smolt_q[i,2],s_smolt_q[i,2],s_smolt_q[i,4],s_smolt_q[i,4]),col=palette_s[15])
	#median
	#segments(i-0.3,s_smolt_q[i,3],i+0.3,s_smolt_q[i,3])
}
dev.off()

}
@





\subsection{Nouvelles figures : répartition des juvéniles de l'année}
\label{res_model_nlle_fig}

<<sortie_graph_bassin, echo=FALSE, eval=TRUE, results=hide>>=

if (chunk_true==1){
##Copier-Coller du script Graph_Juv_Bassin (script/analyse_retro)
###############################################################################################################
#--------------------- Graphique répartition spatiale des juvéniles totaux RATIO------------------------------#
###############################################################################################################

surf=c(rep(c(916866,250441,0),11),rep(c(916866,250441,301101),12),rep(c(916866,250441,383049),6),rep(c(1202540,250441,383049),(T-8)))
S_juv_JP<-matrix(surf,nrow=3)

dmoy_tot_V=read.coda(str_c(datawd,"2016_01_20_standard_thin200/dmoytot_VCODAchain1.txt"),str_c(datawd,"2016_01_20_standard_thin200/dmoytot_VCODAindex.txt"),5001,10000)
dmoy_tot_L=read.coda(str_c(datawd,"2016_01_20_standard_thin200/dmoytot_LCODAchain1.txt"),str_c(datawd,"2016_01_20_standard_thin200/dmoytot_LCODAindex.txt"),5001,10000)
dmoy_tot_P=read.coda(str_c(datawd,"2016_01_20_standard_thin200/dmoytot_PCODAchain1.txt"),str_c(datawd,"2016_01_20_standard_thin200/dmoytot_PCODAindex.txt"),5001,10000)

juv_tot=array(rep(0,195000),dim=c(5000,T))#296000
juv_tot_q=array(rep(0,T*5),dim=c(T,5))

for (t in 2:12){
	juv_tot[,t]= dmoy_tot_V[,t-1] * S_juv_JP[1,t] + dmoy_tot_L[,t-1] * S_juv_JP[2,t]
}
for (t in 13:T){
	juv_tot[,t]= dmoy_tot_V[,t-1] *S_juv_JP[1,t] + dmoy_tot_L[,t-1] *S_juv_JP[2,t] + dmoy_tot_P[,t-12] * S_juv_JP[3,t]	
}

for (i in 1:T){
	juv_tot_q[i,]=quantile(juv_tot[,i],probs=c(0.05,0.25,0.5,0.75,0.95),names=FALSE)
}


##Par secteurs calcul des ratios
juv_V=array(rep(0,195000),dim=c(5000,T))
juv_L=array(rep(0,195000),dim=c(5000,T))
juv_P=array(rep(0,195000),dim=c(5000,T))

ratio_juv_V=array(0,c(5000,T))
ratio_juv_L=array(0,c(5000,T))
ratio_juv_P=array(0,c(5000,T))

ratio_juv_V_q=array(rep(0,T*5),dim=c(T,5))
ratio_juv_L_q=array(rep(0,T*5),dim=c(T,5))
ratio_juv_P_q=array(rep(0,T*5),dim=c(T,5))


for (t in 2:12){
	juv_V[1:5000,t]<-dmoy_tot_V[1:5000,t-1] * S_juv_JP[1,t]
	juv_L[1:5000,t]<-dmoy_tot_L[1:5000,t-1] * S_juv_JP[2,t]
}

for (t in 13:T){
	juv_V[,t]<-dmoy_tot_V[1:5000,t-1] * S_juv_JP[1,t]
	juv_L[,t]<-dmoy_tot_L[1:5000,t-1] * S_juv_JP[2,t]
	juv_P[,t]<-dmoy_tot_P[1:5000,t-12] * S_juv_JP[3,t]
}

for (t in 2:T){
	ratio_juv_V[,t]=juv_V[,t]/juv_tot[,t]
	ratio_juv_L[,t]=juv_L[,t]/juv_tot[,t]
	ratio_juv_P[,t]=juv_P[,t]/juv_tot[,t]
}

for (t in 1:T){
	ratio_juv_V_q[t,]=quantile(ratio_juv_V[,t],probs=c(0.05,0.25,0.5,0.75,0.95),names=FALSE)
	ratio_juv_L_q[t,]=quantile(ratio_juv_L[,t],probs=c(0.05,0.25,0.5,0.75,0.95),names=FALSE)
	ratio_juv_P_q[t,]=quantile(ratio_juv_P[,t],probs=c(0.05,0.25,0.5,0.75,0.95),names=FALSE)
}


pdf(file=str_c(imgwd,"RepartitionSpatiale_juv_totaux_ratio.pdf"),width=8, height=10)
par(mfrow=c(4,1))

#Juv totaux tous secteurs
plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(0,500000),ylab="",main="nombre estimé de juvéniles dans l'ensemble du système")

# trace l'axe des ordonnées
axis(2,at = c(0,100000,200000,300000,400000,500000),
		labels=c(
				expression(0),
				expression(paste(100," x ", 10^3)),
				expression(paste(200," x ", 10^3)),
				expression(paste(300," x ", 10^3)),
				expression(paste(400," x ", 10^3)),
				expression(paste(500," x ", 10^3))),
		cex.axis = 0.8,las = 1,col = "grey55")
# trace l'axe des abscisses
lab1=c(1975,1980,1990,2000,1974+T)
axis(1,at = c(1,6,16,26,T),
		labels=lab1,
		cex.axis = 0.9,las = 1,col = "grey55")

for(i in 2:T){
	#whiskers
	#95%
	segments(i-0.15,juv_tot_q[i,5],i+0.15,juv_tot_q[i,5])
	segments(i,juv_tot_q[i,4],i,juv_tot_q[i,5])
	#5%
	segments(i-0.15,juv_tot_q[i,1],i+0.15,juv_tot_q[i,1])
	segments(i,juv_tot_q[i,2],i,juv_tot_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(juv_tot_q[i,2],juv_tot_q[i,2],juv_tot_q[i,4],juv_tot_q[i,4]),col="grey85")
	#median
	segments(i-0.3,juv_tot_q[i,3],i+0.3,juv_tot_q[i,3])
}

text(41.5,400000,"a)",pos=1,cex = 1.5,font=2)

#Vichy juv totaux ratio
plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(0,1),ylab="",main="ratio pour le secteur Vichy-Langeac (+ Alagnon et Dore)")

# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),
		labels=c(0,0.2,0.4,0.6,0.8,1),
		cex.axis = 0.8,las = 1,col = "grey55")
# trace l'axe des abscisses
lab1=c(1975,1980,1990,2000,1974+T)
axis(1,at = c(1,6,16,26,T),
		labels=lab1,
		cex.axis = 0.9,las = 1,col = "grey55")

for(i in 2:T){
	#whiskers
	#95%
	segments(i-0.15,ratio_juv_V_q[i,5],i+0.15,ratio_juv_V_q[i,5])
	segments(i,ratio_juv_V_q[i,4],i,ratio_juv_V_q[i,5])
	#5%
	segments(i-0.15,ratio_juv_V_q[i,1],i+0.15,ratio_juv_V_q[i,1])
	segments(i,ratio_juv_V_q[i,2],i,ratio_juv_V_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(ratio_juv_V_q[i,2],ratio_juv_V_q[i,2],ratio_juv_V_q[i,4],ratio_juv_V_q[i,4]),col="grey85")
	#median
	segments(i-0.3,ratio_juv_V_q[i,3],i+0.3,ratio_juv_V_q[i,3])
}
abline(h=1,lty=3,col = "grey55")
text(41.5,1,"b)",pos=1,cex = 1.5,font=2)

#Langeac juv totaux ratio
plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(0,1),ylab="",main="ratio pour le secteur Langeac-Poutès")

# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),
		labels=c(0,0.2,0.4,0.6,0.8,1),
		cex.axis = 0.8,las = 1,col = "grey55")
# trace l'axe des abscisses
lab1=c(1975,1980,1990,2000,1974+T)
axis(1,at = c(1,6,16,26,T),
		labels=lab1,
		cex.axis = 0.9,las = 1,col = "grey55")

for(i in 2:T){
	#whiskers
	#95%
	segments(i-0.15,ratio_juv_L_q[i,5],i+0.15,ratio_juv_L_q[i,5])
	segments(i,ratio_juv_L_q[i,4],i,ratio_juv_L_q[i,5])
	#5%
	segments(i-0.15,ratio_juv_L_q[i,1],i+0.15,ratio_juv_L_q[i,1])
	segments(i,ratio_juv_L_q[i,2],i,ratio_juv_L_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(ratio_juv_L_q[i,2],ratio_juv_L_q[i,2],ratio_juv_L_q[i,4],ratio_juv_L_q[i,4]),col="grey85")
	#median
	segments(i-0.3,ratio_juv_L_q[i,3],i+0.3,ratio_juv_L_q[i,3])
}
abline(h=1,lty=3,col = "grey55")

text(41.5,1,"c)",pos=1,cex = 1.5,font=2)

#Poutes juv totaux ratio
plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(0,1),ylab="",main="ratio pour le secteur amont de Poutès")

# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),
		labels=c(0,0.2,0.4,0.6,0.8,1),
		cex.axis = 0.8,las = 1,col = "grey55")
# trace l'axe des abscisses
lab1=c(1975,1980,1990,2000,1974+T)
axis(1,at = c(1,6,16,26,T),
		labels=lab1,
		cex.axis = 0.9,las = 1,col = "grey55")

for(i in 2:T){
	#whiskers
	#95%
	segments(i-0.15,ratio_juv_P_q[i,5],i+0.15,ratio_juv_P_q[i,5])
	segments(i,ratio_juv_P_q[i,4],i,ratio_juv_P_q[i,5])
	#5%
	segments(i-0.15,ratio_juv_P_q[i,1],i+0.15,ratio_juv_P_q[i,1])
	segments(i,ratio_juv_P_q[i,2],i,ratio_juv_P_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(ratio_juv_P_q[i,2],ratio_juv_P_q[i,2],ratio_juv_P_q[i,4],ratio_juv_P_q[i,4]),col="grey85")
	#median
	segments(i-0.3,ratio_juv_P_q[i,3],i+0.3,ratio_juv_P_q[i,3])
}
abline(h=1,lty=3,col = "grey55")

text(41.5,1,"d)",pos=1,cex = 1.5,font=2)

dev.off()	

##################################################################################################################
#--------------------- Graphique répartition spatiale des juvéniles sauvages RATIO ------------------------------#
##################################################################################################################
juv_wild_V=array(rep(0,195000),dim=c(5000,T))
juv_wild_L=array(rep(0,195000),dim=c(5000,T))
juv_wild_P=array(rep(0,195000),dim=c(5000,T))
juv_wild_tot=array(rep(0,195000),dim=c(5000,T))
juv_wild_tot_q=array(rep(0,T*5),dim=c(T,5))


for (t in 2:12){
	juv_wild_V[,t]<-dmoy_wild_V[1:5000,t-1] * S_juv_JP[1,t]
	juv_wild_L[,t]<-dmoy_wild_L[1:5000,t-1] * S_juv_JP[2,t]
}

for (t in 13:T){
	juv_wild_V[,t]<-dmoy_wild_V[1:5000,t-1] * S_juv_JP[1,t]
	juv_wild_L[,t]<-dmoy_wild_L[1:5000,t-1] * S_juv_JP[2,t]
	juv_wild_P[,t]<-dmoy_wild_P[1:5000,t-12] * S_juv_JP[3,t]
}

for (t in 1:T){
	juv_wild_tot[,t]<-juv_wild_V[,t]+juv_wild_L[,t]+juv_wild_P[,t]
}

for (t in 1:T){
	juv_wild_tot_q[t,]=quantile(juv_wild_tot[,t],probs=c(0.05,0.25,0.5,0.75,0.95),names=FALSE)
}

##Ratio par secteurs
ratio_juv_wild_V=array(0,c(5000,T))
ratio_juv_wild_L=array(0,c(5000,T))
ratio_juv_wild_P=array(0,c(5000,T))

ratio_juv_wild_V_q=array(rep(0,T*5),dim=c(T,5))
ratio_juv_wild_L_q=array(rep(0,T*5),dim=c(T,5))
ratio_juv_wild_P_q=array(rep(0,T*5),dim=c(T,5))


for (t in 2:T){
	ratio_juv_wild_V[,t]=juv_wild_V[,t]/juv_wild_tot[,t]
	ratio_juv_wild_L[,t]=juv_wild_L[,t]/juv_wild_tot[,t]
	ratio_juv_wild_P[,t]=juv_wild_P[,t]/juv_wild_tot[,t]
}

for (t in 1:T){
	ratio_juv_wild_V_q[t,]=quantile(ratio_juv_wild_V[,t],probs=c(0.05,0.25,0.5,0.75,0.95),names=FALSE)
	ratio_juv_wild_L_q[t,]=quantile(ratio_juv_wild_L[,t],probs=c(0.05,0.25,0.5,0.75,0.95),names=FALSE)
	ratio_juv_wild_P_q[t,]=quantile(ratio_juv_wild_P[,t],probs=c(0.05,0.25,0.5,0.75,0.95),names=FALSE)
}

pdf(file=str_c(imgwd,"RepartitionSpatiale_juv_wild_ratio.pdf"),width=8, height=10)
par(mfrow=c(4,1))
#Juv tot sauvage
plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(0,500000),ylab="",main="nombre estimé de juvéniles sauvages dans l'ensemble du système")

# trace l'axe des ordonnées
axis(2,at = c(0,100000,200000,300000,400000,500000),
		labels=c(
				expression(0),
				expression(paste(100," x ", 10^3)),
				expression(paste(200," x ", 10^3)),
				expression(paste(300," x ", 10^3)),
				expression(paste(400," x ", 10^3)),
				expression(paste(500," x ", 10^3))),
		cex.axis = 0.8,las = 1,col = "grey55")
# trace l'axe des abscisses
lab1=c(1975,1980,1990,2000,1974+T)
axis(1,at = c(1,6,16,26,T),
		labels=lab1,
		cex.axis = 0.9,las = 1,col = "grey55")

for(i in 2:T){
	#whiskers
	#95%
	segments(i-0.15,juv_wild_tot_q[i,5],i+0.15,juv_wild_tot_q[i,5])
	segments(i,juv_wild_tot_q[i,4],i,juv_wild_tot_q[i,5])
	#5%
	segments(i-0.15,juv_wild_tot_q[i,1],i+0.15,juv_wild_tot_q[i,1])
	segments(i,juv_wild_tot_q[i,2],i,juv_wild_tot_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(juv_wild_tot_q[i,2],juv_wild_tot_q[i,2],juv_wild_tot_q[i,4],juv_wild_tot_q[i,4]),col="grey85")
	#median
	segments(i-0.3,juv_wild_tot_q[i,3],i+0.3,juv_wild_tot_q[i,3])
}

#Vichy ratio
plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(0,1),ylab="",main="proportion de juvéniles sauvages pour le secteur Vichy-Langeac (+ Alagnon et Dore)")

# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),
		labels=c(0,0.2,0.4,0.6,0.8,1),
		cex.axis = 0.8,las = 1,col = "grey55")
# trace l'axe des abscisses
lab1=c(1975,1980,1990,2000,1974+T)
axis(1,at = c(1,6,16,26,T),
		labels=lab1,
		cex.axis = 0.9,las = 1,col = "grey55")

for(i in 2:T){
	#whiskers
	#95%
	segments(i-0.15,ratio_juv_wild_V_q[i,5],i+0.15,ratio_juv_wild_V_q[i,5])
	segments(i,ratio_juv_wild_V_q[i,4],i,ratio_juv_wild_V_q[i,5])
	#5%
	segments(i-0.15,ratio_juv_wild_V_q[i,1],i+0.15,ratio_juv_wild_V_q[i,1])
	segments(i,ratio_juv_wild_V_q[i,2],i,ratio_juv_wild_V_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(ratio_juv_wild_V_q[i,2],ratio_juv_wild_V_q[i,2],ratio_juv_wild_V_q[i,4],ratio_juv_wild_V_q[i,4]),col="grey85")
	#median
	segments(i-0.3,ratio_juv_wild_V_q[i,3],i+0.3,ratio_juv_wild_V_q[i,3])
}
abline(h=1,lty=3,col = "grey55")

#Langeac ratio
plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(0,1),ylab="",main="proportion de juvéniles sauvages pour le secteur Langeac-Poutès")

# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),
		labels=c(0,0.2,0.4,0.6,0.8,1),
		cex.axis = 0.8,las = 1,col = "grey55")
# trace l'axe des abscisses
lab1=c(1975,1980,1990,2000,1974+T)
axis(1,at = c(1,6,16,26,T),
		labels=lab1,
		cex.axis = 0.9,las = 1,col = "grey55")

for(i in 2:T){
	#whiskers
	#95%
	segments(i-0.15,ratio_juv_wild_L_q[i,5],i+0.15,ratio_juv_wild_L_q[i,5])
	segments(i,ratio_juv_wild_L_q[i,4],i,ratio_juv_wild_L_q[i,5])
	#5%
	segments(i-0.15,ratio_juv_wild_L_q[i,1],i+0.15,ratio_juv_wild_L_q[i,1])
	segments(i,ratio_juv_wild_L_q[i,2],i,ratio_juv_wild_L_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(ratio_juv_wild_L_q[i,2],ratio_juv_wild_L_q[i,2],ratio_juv_wild_L_q[i,4],ratio_juv_wild_L_q[i,4]),col="grey85")
	#median
	segments(i-0.3,ratio_juv_wild_L_q[i,3],i+0.3,ratio_juv_wild_L_q[i,3])
}
abline(h=1,lty=3,col = "grey55")
#Poutes ratio
plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(0,1),ylab="",main="proportion de juvéniles sauvages pour le secteur amont de Poutès")

# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),
		labels=c(0,0.2,0.4,0.6,0.8,1),
		cex.axis = 0.8,las = 1,col = "grey55")
# trace l'axe des abscisses

lab1=c(1975,1980,1990,2000,1974+T)
axis(1,at = c(1,6,16,26,T),
		labels=lab1,
		cex.axis = 0.9,las = 1,col = "grey55")

for(i in 2:T){
	#whiskers
	#95%
	segments(i-0.15,ratio_juv_wild_P_q[i,5],i+0.15,ratio_juv_wild_P_q[i,5])
	segments(i,ratio_juv_wild_P_q[i,4],i,ratio_juv_wild_P_q[i,5])
	#5%
	segments(i-0.15,ratio_juv_wild_P_q[i,1],i+0.15,ratio_juv_wild_P_q[i,1])
	segments(i,ratio_juv_wild_P_q[i,2],i,ratio_juv_wild_P_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(ratio_juv_wild_P_q[i,2],ratio_juv_wild_P_q[i,2],ratio_juv_wild_P_q[i,4],ratio_juv_wild_P_q[i,4]),col="grey85")
	#median
	segments(i-0.3,ratio_juv_wild_P_q[i,3],i+0.3,ratio_juv_wild_P_q[i,3])
}
abline(h=1,lty=3,col = "grey55")

dev.off()
}
@

<<graph_alevinage, echo=FALSE, eval=TRUE, results=hide>>=
if (chunk_true==1){
	
#Récupération du CSV qui synthétise les quantités alevinées (copier/coller du excel "deversements allier_récapitulatif_maj2015_11_17" onglet summary 3 sector
alv<-read.csv("C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/data/AlevinageSecteur.csv",sep=";")
alv$Secteur<-as.factor(alv$Secteur)
#alv$Annee<-as.factor(alv$Annee)
alv$sec<-0
alv$sec<-ifelse (alv$Secteur==1, 1, 2)
alv$alv<-ifelse (alv$sec>1,alv$Alevin[alv$Secteur==2] +alv$Alevin[alv$Secteur==3],alv$Alevin)
#attention ça réplique les données pour alv$alv quand secteur=3. Ne conserver que les 80 premières lignes
alv<-alv[as.numeric(alv$Secteur)<3,c(1,4,5)]
alv$sec<-as.factor(alv$sec)
alv$Secteur<-ifelse (alv$sec==1,"Vichy-Langeac + Alagnon + Dore","Amont de Langeac")

#p<-ggplot(data=alv, aes(x=Annee, y=alv, fill=sec)) + 
#			geom_bar(stat="identity")


ggplot(data=alv, aes(x=Annee, y=alv, fill=Secteur)) + geom_bar(stat="identity") +
		scale_fill_manual(values=c("#000000","#999999"))+ labs(x="Années", y="Nombre d'alevins déversés", fill="Secteurs") +
		scale_x_continuous(breaks=seq(1975,2015,5))

ggsave(str_c(imgwd,"Alv_deverse.pdf"),width=8,height=7)

}	
@

<< res_wild_poutes, echo=FALSE, eval=TRUE,results=hide >>=

if (chunk_true==1){

res_wild_poutes=read.coda(str_c(datawd,"2016_01_20_standard_thin200/res_wild_PCODAchain1.txt"),str_c(datawd,"2016_01_20_standard_thin200/res_wild_PCODAindex.txt"))

sum=summary(res_wild_poutes, probs=seq(0,1,0.1))
res_wild_poutes_q<-sum$quantiles
mean_res<-cbind(sum$statistics[,"Mean"])


pdf(file=str_c(imgwd,"res_wild_poutes.pdf"),width=6,height=6)

plot(1,1,type="n",axes=FALSE,xlim=c(0,(T-12+1)),xlab="Années",ylim=c(-2,2),ylab="Résidus du recrutement à l'amont de Poutès")

# trace l'axe des ordonnées
axis(2,at = seq(-2,2,by=1),labels=c(-2,-1,0,1,2),cex.axis = 0.9,las = 1,col = "grey55")
# trace l'axe des abscisses
lab1=c(1987,1990,2000,2010,1974+T)
axis(1,at = c(1,4,14,24,(T-12)),
		labels=lab1,
		cex.axis = 0.9,las = 1,col = "grey55")

for(i in 1:(T-12)){
	#whiskers
	#95%
	segments(i-0.15,res_wild_poutes_q[i,5],i+0.15,res_wild_poutes_q[i,5])
	segments(i,res_wild_poutes_q[i,4],i,res_wild_poutes_q[i,5])
	#5%
	segments(i-0.15,res_wild_poutes_q[i,1],i+0.15,res_wild_poutes_q[i,1])
	segments(i,res_wild_poutes_q[i,2],i,res_wild_poutes_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(res_wild_poutes_q[i,2],res_wild_poutes_q[i,2],res_wild_poutes_q[i,4],res_wild_poutes_q[i,4]),col="green")
	#mean
	segments(i-0.3,mean_res[i,],i+0.3,mean_res[i,])
}


segments(x0=0,y0=mean(mean_res),y1=mean(mean_res),x1=30,col="red")
mtext(round(mean(mean_res),3),side=4,line=0,at=mean(mean_res),cex = 0.8,col="red",las=1)
dev.off()

}
@


La figure \ref{rep_juv_bassin} permet de
mettre en évidence une modification relativement récente dans la répartition des
juvéniles dans les 3 secteurs. En effet, nous constatons
que depuis 2008, le ratio des juvéniles présents dans le secteur en amont
de Poutès a considérablement et très subitement chuté, tandis qu'il a
augmenté sur le secteur aval (Vichy-Langeac). Le secteur
intermédiaire (Langeac-Poutès) est, quant à lui, resté assez stable. Cette
modification correspond au changement important intervenu dans la stratégie de repeuplement. 
En effet, depuis 2008, plus aucun alevin n'est déversé en amont de Langeac 
(depuis 2009 tout déversement, y compris au stade oeuf, a cessé dans cette zone), 
l'année 2007 ayant été une année de transition entre les 2 stratégies de déversement, 
l'une consistant (avant 2007) à déverser la majorité
des poissons en amont de Langeac et l'autre (depuis 2008) consistant à
déverser tous les alevins produits en aval de Langeac (figure \ref{alv_dev}).
Cela montre également que la zone en amont de Poutès était très sensible à
l'ajout de juvéniles (via les déversements) tandis que la zone Langeac-Poutès ne
l'est quasiment pas (pas de modification depuis l'arrêt des déversements).\\
Le fait que nous observions une baisse importante de la production de l'amont de
Poutès (par rapport à la production totale) alors que le ratio de géniteurs n'a
pas changé pour ce secteur nous interpelle sur le recrutement dans cette zone
depuis 2008. La figure \ref{res_wild_p} présente les résidus naturel du recrutement à
Poutès (variable res\_wild\_moy\_P dans le modèle).
Nous observons sur cette figure des résidus atypiques depuis 2007, avec des
résidus négatifs 5 années sur 8. La figure \ref{rep_juv_wild_bassin} qui
présente la répartition des juvéniles issus de la reproduction naturelle met en
évidence la même tendance à la baisse sur ce secteur.
Nous ne sommes pas en mesure aujourd'hui d'expliquer ces résidus négatifs et
cela constituera une des perspectives de travail (cf. section
\ref{perspectives}).





\section{Simulation sans repeuplement et projections à 20 ans}
\label{res_simul}

\noindent Suite aux différentes corrections et améliorations apportées au modèle
en 2015, les principaux scénarii développés par \citet{dauphin_viability_2013}
et \citet{legrand_transfert_2014} ont été mis à jour et sont présentés dans
cette section \footnote{se référer aux rapports de \citet{dauphin_viability_2013} et
\citet{legrand_transfert_2014} pour plus de détails sur les scénarii produits}.
Il s'agit de :
\begin{itemize}
  \item une analyse rétrospective dans un scénario où aucun repeuplement
  n'aurait eu lieu (section \ref{res_retour_futur}),
  \item un scénario d'arrêt des repeuplements dès l'année prochaine avec une
  projection des retours à Vichy à 20 ans (section \ref{res_retour_20ans}),
  \item deux scénarii d'arrêt des reppeuplements dès l'année prochaine et une
  amélioration au niveau du barrage de Poutès à la montaison comme à la
  dévalaison (section \ref{res_poutes}),
  \item deux scénarii d'arrêt des repeuplements dès l'année prochaine et une
  augmentation progressive (sur 10 ans) du taux de transition entre le tacon 0+
  et l'adulte par rapport au niveau initial observé au milieu des années 1980
  (section \ref{res_survie}).
\end{itemize}
En plus de ces scénarii mis à jour, sont présentés les résultats du scénario
développé en 2015 lié à la suppression des impacts lors de la dévalaison dans
les ouvrages hydroélectriques (section \ref{res_deval} - voir section
\ref{scenario_deval} pour les explications sur ce scénario).

\subsection{Retour vers le futur : Et si on n'avait jamais repeuplé ?}
\label{res_retour_futur}

<<Retour_futur, echo=FALSE, eval=TRUE,results=hide>>=

if (chunk_true==1){
################################################
# Retour vers le futur
################################################
#On commence par faire tourner le script SimulationWithoutStocking_REtrospectiveAnalysis et enregistrer le Rdata
load(file = "C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/script/lateX/data/2016_03_15_AnalyseRetro.Rdata")
N_vichy_real=read.coda(str_c(datawd,"2016_01_20_standard_thin200/simulation/N_vichy_realCODAchain1.txt"),str_c(datawd,"2016_01_20_standard_thin200/simulation/N_vichy_realCODAindex.txt"))

N_vichy_real_q=array(NA,dim=c((T+20-15),5))
N_vichy_q=array(NA,dim=c(T,5))

for (t in 1:T){
	N_vichy_q[t,]=quantile(N_vichy[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}

#Attention à l'année 30 estimation des passages à Vichy car année jugée incomplète
for (t in 1:22){
	N_vichy_real_q[t,]=quantile(N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}
for(t in 23:23){
	N_vichy_real_q[(t+7),]=quantile(N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}

data_vichy=c(
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,393,267,515,
		380,400,541,1238,NA,
		510,950,572,421,491,
		227,755,861,819,595)

diff_N_vichy=array(0,dim=c(5000,T))

for (t in 7:22){
	for (i in 1:5000){
		diff_N_vichy[i,t]=N_vichy_real[i,t]-N_vichy[i,t]
} }
for (t in 23:29){
	for (i in 1:5000){
		diff_N_vichy[i,t]=data_vichy[t]-N_vichy[i,t]
} }
for (t in 30:30){
	for (i in 1:5000){
		diff_N_vichy[i,t]=N_vichy_real[i,(t-7)]-N_vichy[i,t]
} }
for (t in 31:T){
	for (i in 1:5000){
		diff_N_vichy[i,t]=data_vichy[t]-N_vichy[i,t] 
} }

diff_N_vichy_q=array(0,dim=c(T,5))
for (t in 7:T){
	diff_N_vichy_q[t,]=quantile(diff_N_vichy[,t],probs=c(0.025,0.25,0.5,0.75,0.975),na.rm=TRUE,names=FALSE)
}

pourcentage_N_vichy=array(0,dim=c(5000,T))


for (t in 7:22){
	for (i in 1:5000){
		pourcentage_N_vichy[i,t]=(N_vichy_real[i,t]-N_vichy[i,t])/N_vichy_real[i,t]
	}
} 

for (t in 23:29){
	for (i in 1:5000){
		pourcentage_N_vichy[i,t]=(data_vichy[t]-N_vichy[i,t])/data_vichy[t] 
	}
} 
#On estime l'année 2004 car comptage partiel. t-7 car année 30 à la suite des 22 premières année soit 23eme ligne de N_vichy_real
for (t in 30:30){
	for (i in 1:5000){
		pourcentage_N_vichy[i,t]=(N_vichy_real[i,(t-7)]-N_vichy[i,t])/N_vichy_real[i,(t-7)]
	}
} 

for (t in 31:T){
	for (i in 1:5000){
		pourcentage_N_vichy[i,t]=(data_vichy[t]-N_vichy[i,t]) /data_vichy[t] 
	}
} 


pourcentage_N_vichy_q=array(0,dim=c(T,5))

for (t in 7:T){
	pourcentage_N_vichy_q[t,]=quantile(pourcentage_N_vichy[,t],probs=c(0.025,0.25,0.5,0.75,0.975),na.rm=TRUE,names=FALSE)
}


pdf(file=str_c(imgwd,"RetourVersLeFutur_2016_03_15.pdf"))#,width=800,height=800)

par(mfrow=c(2,2))


plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(0,9000),ylab="Retours à Vichy",main="Avec repeuplement",cex.lab=1.2)

# trace l'axe des ordonnées
axis(2,at = c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),labels=c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),cex.axis = 1,las = 1,lwd=2,col = "black")
# trace l'axe des abscisses
axis(1,at = c(1,6,16,26,T),
		labels=c(1975,1980,1990,2000,1974+T),
		cex.axis = 1.2,las = 1,lwd=2,col = "black")

for(i in 3:30){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_real_q[i,5],i+0.15,N_vichy_real_q[i,5])
	segments(i,N_vichy_real_q[i,4],i,N_vichy_real_q[i,5])
	#5%
	segments(i-0.15,N_vichy_real_q[i,1],i+0.15,N_vichy_real_q[i,1])
	segments(i,N_vichy_real_q[i,2],i,N_vichy_real_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_real_q[i,2],N_vichy_real_q[i,2],N_vichy_real_q[i,4],N_vichy_real_q[i,4]),col="light grey")
	#median
	segments(i-0.3,N_vichy_real_q[i,3],i+0.3,N_vichy_real_q[i,3])
}


data_vichy=c(
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,393,267,515,
		380,400,541,1238,NA,
		510,950,572,421,491,
		227,755,861,819,595)



points(x=seq(23,T,1),data_vichy[23:T],pch=16)

plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(0,9000),ylab="Retour à Vichy",main="Simulation sans repeuplement",cex.lab=1.2)

# trace l'axe des ordonnées
axis(2,at = c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),labels=c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),cex.axis = 1,las = 1,lwd=2,col = "black")
# trace l'axe des abscisses
axis(1,at = c(1,6,16,26,T),
		labels=c(1975,1980,1990,2000,1974+T),
		cex.axis = 1.2,las = 1,lwd=2,col = "black")


for(i in 3:6){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_real_q[i,5],i+0.15,N_vichy_real_q[i,5])
	segments(i,N_vichy_real_q[i,4],i,N_vichy_real_q[i,5])
	#5%
	segments(i-0.15,N_vichy_real_q[i,1],i+0.15,N_vichy_real_q[i,1])
	segments(i,N_vichy_real_q[i,2],i,N_vichy_real_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_real_q[i,2],N_vichy_real_q[i,2],N_vichy_real_q[i,4],N_vichy_real_q[i,4]),col="light grey")
	#median
	segments(i-0.3,N_vichy_real_q[i,3],i+0.3,N_vichy_real_q[i,3])
}



for(i in 7:T){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_q[i,5],i+0.15,N_vichy_q[i,5])
	segments(i,N_vichy_q[i,4],i,N_vichy_q[i,5])
	#5%
	segments(i-0.15,N_vichy_q[i,1],i+0.15,N_vichy_q[i,1])
	segments(i,N_vichy_q[i,2],i,N_vichy_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_q[i,2],N_vichy_q[i,2],N_vichy_q[i,4],N_vichy_q[i,4]),col="light grey")
	#median
	segments(i-0.3,N_vichy_q[i,3],i+0.3,N_vichy_q[i,3])
}

plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(-500,1500),ylab=expression(Returns^stocking-Returns^without),main="Difference des retours à Vichy \n avec ou sans repeuplement",cex.lab=1.2)

# trace l'axe des ordonnées
axis(2,at = c(-500,0,500,1000,1500),labels=c(-500,0,500,1000,1500),cex.axis = 1,las = 1,lwd=2,col = "black")
# trace l'axe des abscisses
axis(1,at = c(1,6,16,26,T),
		labels=c(1975,1980,1990,2000,1974+T),
		cex.axis = 1.2,las = 1,lwd=2,col = "black")


points(x=c(3,4,5,6),y=c(1,1,1,1),pch=16)


for(i in 7:T){
	#whiskers
	#95%
	segments(i-0.15,diff_N_vichy_q[i,5],i+0.15,diff_N_vichy_q[i,5])
	segments(i,diff_N_vichy_q[i,4],i,diff_N_vichy_q[i,5])
	#5%
	segments(i-0.15,diff_N_vichy_q[i,1],i+0.15,diff_N_vichy_q[i,1])
	segments(i,diff_N_vichy_q[i,2],i,diff_N_vichy_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(diff_N_vichy_q[i,2],diff_N_vichy_q[i,2],diff_N_vichy_q[i,4],diff_N_vichy_q[i,4]),col="light grey")
	#median
	segments(i-0.3,diff_N_vichy_q[i,3],i+0.3,diff_N_vichy_q[i,3])
}

segments(1,0,38,lty=2,col="red")


plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+0.5),xlab="Années",ylim=c(0,1),ylab="%repeuplement",main="Contribution du repeuplement \n aux retours d'adultes",cex.lab = 1.2)

# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,20,40,60,80,100),cex.axis = 1,las = 1,lwd=2,col = "black")
# trace l'axe des abscisses
axis(1,at = c(1,6,16,26,T),
		labels=c(1975,1980,1990,2000,1974+T),
		cex.axis = 1.2,las = 1,lwd=2,col = "black")

#text(T,15,labels=expression(italic("a.")))


for(i in 7:T){
	#whiskers
	#95%
	segments(i-0.15,pourcentage_N_vichy_q[i,5],i+0.15,pourcentage_N_vichy_q[i,5])
	segments(i,pourcentage_N_vichy_q[i,4],i,pourcentage_N_vichy_q[i,5])
	#5%
	segments(i-0.15,pourcentage_N_vichy_q[i,1],i+0.15,pourcentage_N_vichy_q[i,1])
	segments(i,pourcentage_N_vichy_q[i,2],i,pourcentage_N_vichy_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(pourcentage_N_vichy_q[i,2],pourcentage_N_vichy_q[i,2],pourcentage_N_vichy_q[i,4],pourcentage_N_vichy_q[i,4]),col="light grey")
	#median
	segments(i-0.3,pourcentage_N_vichy_q[i,3],i+0.3,pourcentage_N_vichy_q[i,3])
}
dev.off()
}

@

L'analyse rétrospective dans le scénario où aucun repeuplement n'aurait eu
lieu dans le bassin Loire, indique que le repeuplement joue un rôle important
dans le retour des adultes à Vichy depuis ces 15 dernières années.
La contribution des repeuplements dans les retours d'adultes tient compte ici :


\subsection{Projection à 20 ans sans changement autre que l'arrêt des
déversements}
\label{res_retour_20ans}

<<Retour_20ans, echo=FALSE, eval=TRUE, results=hide>>=

if(chunk_true==1){

#On récupère les données du script ProjectionModelWhithoutStocking :
load("C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/2016_01_20_ProjectionSansRepeuplement_2016.03.11.RData")
#============================
# PROJECTION SUR LES 20 ANS 
#============================
#==========================================
# CHAP : Figure : TotalReturns_proj20years
#==========================================
ras_N_vichy<-N_vichy
	
# Graph projection 20 years
bugs_N_vichy_real=read.coda(str_c(datawd,"2016_01_20_standard_thin200/simulation/N_vichy_realCODAchain1.txt"),str_c(datawd,"2016_01_20_standard_thin200/simulation/N_vichy_realCODAindex.txt"))
N_vichy_real_q=array(NA,dim=c(44,5))#44 car il y a 16 année de suivi station (soit T+20 - 15)

#Attention à l'année 30 estimation des passages Vichy car année jugée incomplète
for (t in 1:22){
	N_vichy_real_q[t,]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}
for(t in 23:23){
	N_vichy_real_q[(t+7),]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}

#N_vichy_proj_q=array(0,dim=c(43,5))
N_vichy_proj_q=array(0,dim=c(T+20,5))
for (t in (T+1):(T+20)){
	N_vichy_proj_q[t,]=quantile(ras_N_vichy[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}
#------------------
# Graph
#------------------

pdf(file=str_c(imgwd,"TotalReturns_proj20years_2016_03_11.pdf"))#,width=800,height=800)

plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+20+0.5),xlab="Années",ylim=c(0,9000),ylab="Retours à Vichy",main="Projection à 20 ans sans repeuplement",cex.lab=1.2)
# trace l'axe des ordonnées
axis(2,at = c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),labels=c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),cex.axis = 1,las = 1,lwd=2,col = "black")
# trace l'axe des abscisses
axis(1,at = c(1,6,16,26,T,T+10,T+20),
		labels=c(1975,1980,1990,2000,1974+T,1974+T+10,(T+1974+20)),
		cex.axis = 1,las = 1,lwd=2,col = "black")
for(i in 3:30){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_real_q[i,5],i+0.15,N_vichy_real_q[i,5])
	segments(i,N_vichy_real_q[i,4],i,N_vichy_real_q[i,5])
	#5%
	segments(i-0.15,N_vichy_real_q[i,1],i+0.15,N_vichy_real_q[i,1])
	segments(i,N_vichy_real_q[i,2],i,N_vichy_real_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_real_q[i,2],N_vichy_real_q[i,2],N_vichy_real_q[i,4],N_vichy_real_q[i,4]),col="light grey")
	#median
	segments(i-0.3,N_vichy_real_q[i,3],i+0.3,N_vichy_real_q[i,3])
}
data_vichy=c(
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,393,267,515,
		380,400,541,1238,NA,#662,
		510,950,572,421,491,
		227,755,861,819,595)
points(x=seq(23,T,1),data_vichy[23:T],pch=16)

for(i in (T+1):(T+20)){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_proj_q[i,5],i+0.15,N_vichy_proj_q[i,5])
	segments(i,N_vichy_proj_q[i,4],i,N_vichy_proj_q[i,5])
	#5%
	segments(i-0.15,N_vichy_proj_q[i,1],i+0.15,N_vichy_proj_q[i,1])
	segments(i,N_vichy_proj_q[i,2],i,N_vichy_proj_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_proj_q[i,2],N_vichy_proj_q[i,2],N_vichy_proj_q[i,4],N_vichy_proj_q[i,4]),col="orange")
	#median
	segments(i-0.3,N_vichy_proj_q[i,3],i+0.3,N_vichy_proj_q[i,3])
}
dev.off()

under_10_vichy=array(0,dim=c(8000,20))
under_50_vichy=array(0,dim=c(8000,20))
under_100_vichy=array(0,dim=c(8000,20))
under_250_vichy=array(0,dim=c(8000,20))
under_500_vichy=array(0,dim=c(8000,20))


for (t in (T+1):(T+20)){
	
	for (i in 1:5000){
		if(ras_N_vichy[i,t] < 10){under_10_vichy[i,t-T]=1}  
		if(ras_N_vichy[i,t] < 50){under_50_vichy[i,t-T]=1}
		if(ras_N_vichy[i,t] < 100){under_100_vichy[i,t-T]=1}
		if(ras_N_vichy[i,t] < 250){under_250_vichy[i,t-T]=1}
		if(ras_N_vichy[i,t] < 500){under_500_vichy[i,t-T]=1}
		
	}
}


ras_p_under_10_vichy=rep(0,20)
ras_p_under_50_vichy=rep(0,20)
ras_p_under_100_vichy=rep(0,20)
ras_p_under_250_vichy=rep(0,20)
ras_p_under_500_vichy=rep(0,20)


for (t in 1:20){
	ras_p_under_10_vichy[t]=mean(under_10_vichy[,t])
	ras_p_under_50_vichy[t]=mean(under_50_vichy[,t])
	ras_p_under_100_vichy[t]=mean(under_100_vichy[,t])
	ras_p_under_250_vichy[t]=mean(under_250_vichy[,t])
	ras_p_under_500_vichy[t]=mean(under_500_vichy[,t])
	
}

pdf(file=str_c(imgwd,"Threshold_2016_03_11.pdf"))#,width=800,height=800)

par(mfrow=c(1,1),mar=c(4,6.1,2,0.5),cex.lab=1.4, cex.lab=1.4)

plot(1,1,type="n",axes=FALSE,xlim=c(0.5,20.5),xlab="Années",ylim=c(0,1),ylab=expression(italic(p^seuils)),cex.lab=1.5)
# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 0.9,las = 1,col = "black")
# trace l'axe des abscisses
axis(1,at = c(1,9,20),
		labels=c(1975+T,1975+T+9,1975+T+19),
		cex.axis = 0.9,las = 1,col = "black")

x=seq(1,20,1)



points(x,ras_p_under_10_vichy,col="grey85",pch=16)
segments(x[1:19],ras_p_under_10_vichy[1:19],x[2:20],ras_p_under_10_vichy[2:20],col="grey85")

points(x,ras_p_under_50_vichy,col="grey75",pch=16)
segments(x[1:19],ras_p_under_50_vichy[1:19],x[2:20],ras_p_under_50_vichy[2:20],col="grey75")

points(x,ras_p_under_100_vichy,col="grey65",pch=16)
segments(x[1:19],ras_p_under_100_vichy[1:19],x[2:20],ras_p_under_100_vichy[2:20],col="grey65")

points(x,ras_p_under_250_vichy,col="grey55",pch=16)
segments(x[1:19],ras_p_under_250_vichy[1:19],x[2:20],ras_p_under_250_vichy[2:20],col="grey55")

points(x,ras_p_under_500_vichy,col="grey45",pch=16)
segments(x[1:19],ras_p_under_500_vichy[1:19],x[2:20],ras_p_under_500_vichy[2:20],col="grey45")


legend(15,1,legend=c(expression(p^seuils < 500),expression(p^seuils < 250),expression(p^seuils < 100),expression(p^seuils < 50),expression(p^seuils < 10)),
		pch=c(16,16,16,16,16),col=c("grey45","grey55","grey65","grey75","grey85"),bty="n" )


dev.off()

}
@



\FloatBarrier

\subsection{Projection à 20 ans avec une amélioration des conditions de
montaison et de dévalaison à Poutès}
\label{res_poutes}
\subsubsection{Amélioration de la montaison et de la dévalaison à hauteur de 50\%}

<<Retour_20ans_poutes50, echo=FALSE, eval=TRUE, results=hide>>=

if(chunk_true==1){

#On charge le jeu de données générés dans le script SimulationOuverturePoutes
load("C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/2016_01_20_Standard_OuverturePoutes50_2016_03_11.RData")
#============================
# PROJECTION SUR LES 20 ANS 
#============================
#==========================================
# CHAP : Figure : TotalReturns_proj20years
#==========================================
#Renomme N_vichy pour pouvoir faire calcul dans sweave sans que ça reste sur la dernière valeur si je relance le script
p50_N_vichy<-N_vichy
# Graph projection 20 years
	bugs_N_vichy_real=read.coda(str_c(datawd,"2016_01_20_standard_thin200/simulation/N_vichy_realCODAchain1.txt"),str_c(datawd,"2016_01_20_standard_thin200/simulation/N_vichy_realCODAindex.txt"))
	N_vichy_real_q=array(NA,dim=c(44,5))#4 car il y a 17 année de suivi station (soit T+20 - 15)
	
#Attention à l'année 30 estimation des passages Vichy car année jugée incomplète
	for (t in 1:22){
		N_vichy_real_q[t,]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
	}
	for(t in 23:23){
		N_vichy_real_q[(t+7),]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
	}
	
#N_vichy_proj_q=array(0,dim=c(43,5))
	N_vichy_proj_q=array(0,dim=c(T+20,5))
	for (t in (T+1):(T+20)){
		N_vichy_proj_q[t,]=quantile(p50_N_vichy[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
	}
	
#------------------
# Graph
#------------------
pdf(file=str_c(imgwd,"50poutes_TotalReturns_proj20years_2016_01_20.pdf"))
	
	plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+20+0.5),xlab="Years",ylim=c(0,9000),ylab="Returns Vichy",main="Projection à 20 ans sans repeuplement - Amélioration à la montaison  \n et à la dévalaison à Poutès à hauteur de 50%",cex.lab=1.5)
	
# trace l'axe des ordonnées
	axis(2,at = c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),labels=c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),cex.axis = 1.2,las = 1,lwd=2,col = "black")
# trace l'axe des abscisses
	lab1=c(1975,1980,1990,2000,1974+T,1974+T+10,1974+T+20)
	axis(1,at = c(1,6,16,26,T,T+10,T+20),
			labels=lab1,
			cex.axis = 1.2,las = 1,lwd=2,col = "black")
	
	
	for(i in 3:30){
		#whiskers
		#95%
		segments(i-0.15,N_vichy_real_q[i,5],i+0.15,N_vichy_real_q[i,5])
		segments(i,N_vichy_real_q[i,4],i,N_vichy_real_q[i,5])
		#5%
		segments(i-0.15,N_vichy_real_q[i,1],i+0.15,N_vichy_real_q[i,1])
		segments(i,N_vichy_real_q[i,2],i,N_vichy_real_q[i,1])
		#boxplot
		polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_real_q[i,2],N_vichy_real_q[i,2],N_vichy_real_q[i,4],N_vichy_real_q[i,4]),col="light grey")
		#median
		segments(i-0.3,N_vichy_real_q[i,3],i+0.3,N_vichy_real_q[i,3])
	}
	
	
	data_vichy=c(
			NA,NA,NA,NA,NA,
			NA,NA,NA,NA,NA,
			NA,NA,NA,NA,NA,
			NA,NA,NA,NA,NA,
			NA,NA,393,267,515,
			380,400,541,1238,NA,#662,
			510,950,572,421,491,
			227,755,861,819,595)
	points(x=seq(23,T,1),data_vichy[23:T],pch=16)
	
	for(i in (T+1):(T+20)){
		#whiskers
		#95%
		segments(i-0.15,N_vichy_proj_q[i,5],i+0.15,N_vichy_proj_q[i,5])
		segments(i,N_vichy_proj_q[i,4],i,N_vichy_proj_q[i,5])
		#5%
		segments(i-0.15,N_vichy_proj_q[i,1],i+0.15,N_vichy_proj_q[i,1])
		segments(i,N_vichy_proj_q[i,2],i,N_vichy_proj_q[i,1])
		#boxplot
		polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_proj_q[i,2],N_vichy_proj_q[i,2],N_vichy_proj_q[i,4],N_vichy_proj_q[i,4]),col="orange")
		#median
		segments(i-0.3,N_vichy_proj_q[i,3],i+0.3,N_vichy_proj_q[i,3])
	}
	
dev.off()

under_10_vichy=array(0,dim=c(8000,20))
under_50_vichy=array(0,dim=c(8000,20))
under_100_vichy=array(0,dim=c(8000,20))
under_250_vichy=array(0,dim=c(8000,20))
under_500_vichy=array(0,dim=c(8000,20))


for (t in (T+1):(T+20)){
	
	for (i in 1:5000){
		if(p50_N_vichy[i,t] < 10){under_10_vichy[i,(t-T)]=1}  
		if(p50_N_vichy[i,t] < 50){under_50_vichy[i,(t-T)]=1}
		if(p50_N_vichy[i,t] < 100){under_100_vichy[i,(t-T)]=1}
		if(p50_N_vichy[i,t] < 250){under_250_vichy[i,t-T]=1}
		if(p50_N_vichy[i,t] < 500){under_500_vichy[i,(t-T)]=1}
		
	}
}


p50_p_under_10_vichy=rep(0,20)
p50_p_under_50_vichy=rep(0,20)
p50_p_under_100_vichy=rep(0,20)
p50_p_under_250_vichy=rep(0,20)
p50_p_under_500_vichy=rep(0,20)


for (t in 1:20){
	p50_p_under_10_vichy[t]=mean(under_10_vichy[,t])
	p50_p_under_50_vichy[t]=mean(under_50_vichy[,t])
	p50_p_under_100_vichy[t]=mean(under_100_vichy[,t])
	p50_p_under_250_vichy[t]=mean(under_250_vichy[,t])
	p50_p_under_500_vichy[t]=mean(under_500_vichy[,t])
	
}

pdf(file=str_c(imgwd,"50poutes_Threshold_2016_01_20.pdf"))#,width=800,height=800)

par(mfrow=c(1,1),mar=c(4,6.1,2,0.5),cex.lab=1.4, cex.lab=1.4)

plot(1,1,type="n",axes=FALSE,xlim=c(0.5,20.5),xlab="Years",ylim=c(0,1),ylab=expression(italic(p^threshold)),main="")

# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 0.9,las = 1,col = "black")
# trace l'axe des abscisses
lab2=c(1975+T,1975+T+9,1975+T+19)
axis(1,at = c(1,10,20),
		labels=lab2,
		cex.axis = 0.9,las = 1,col = "black")

x=seq(1,20,1)



points(x,p50_p_under_10_vichy,col="grey85",pch=16)
segments(x[1:19],p50_p_under_10_vichy[1:19],x[2:20],p50_p_under_10_vichy[2:20],col="grey85")
#
points(x,p50_p_under_50_vichy,col="grey75",pch=16)
segments(x[1:19],p50_p_under_50_vichy[1:19],x[2:20],p50_p_under_50_vichy[2:20],col="grey75")

points(x,p50_p_under_100_vichy,col="grey65",pch=16)
segments(x[1:19],p50_p_under_100_vichy[1:19],x[2:20],p50_p_under_100_vichy[2:20],col="grey65")

points(x,p50_p_under_250_vichy,col="grey55",pch=16)
segments(x[1:19],p50_p_under_250_vichy[1:19],x[2:20],p50_p_under_250_vichy[2:20],col="grey55")

points(x,p50_p_under_500_vichy,col="grey45",pch=16)
segments(x[1:19],p50_p_under_500_vichy[1:19],x[2:20],p50_p_under_500_vichy[2:20],col="grey45")


legend(15,1,legend=c(expression(p^treshold < 500),expression(p^treshold < 250),expression(p^treshold < 100),expression(p^treshold < 50)), #,expression(p^treshold < 250),expression(p^treshold < 100),expression(p^treshold < 50),expression(p^treshold < 10)),
		pch=c(16,16,16),#,16,16)
		col=c("grey45","grey55","grey65","grey75"),#"grey75","grey85")
		bty="n" )


dev.off()
}
@



\FloatBarrier



\subsubsection{Suppression du barrage de Poutès (ou amélioration à hauteur de 100\%)}
<<Retour_20ans_poutes100, echo=FALSE, eval=TRUE, results=hide>>=

#On récupère les data dans le script SimulationOuverturePoutes
if(chunk_true==1){

load("C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/2016_01_20_OuverturePoutes100_2016_03_11.RData")
#============================
# PROJECTION SUR LES 20 ANS 
#============================
#==========================================
# CHAP : Figure : TotalReturns_proj20years
#==========================================
#Renomme N_vichy pour pouvoir faire calcul dans sweave sans que ça reste sur la dernière valeur si je relance le script
p100_N_vichy<-N_vichy
# Graph projection 20 years
bugs_N_vichy_real=read.coda(str_c(datawd,"2016_01_20_standard_thin200/simulation/N_vichy_realCODAchain1.txt"),str_c(datawd,"2016_01_20_standard_thin200/simulation/N_vichy_realCODAindex.txt"))
N_vichy_real_q=array(NA,dim=c(44,5))#44 car il y a 16 année de suivi station (soit T+20 - 15)

#Attention à l'année 30 estimation des passages Vichy car année jugée incomplète
for (t in 1:22){
	N_vichy_real_q[t,]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}
for(t in 23:23){
	N_vichy_real_q[(t+7),]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}

#N_vichy_proj_q=array(0,dim=c(43,5))
N_vichy_proj_q=array(0,dim=c(T+20,5))
for (t in (T+1):(T+20)){
	N_vichy_proj_q[t,]=quantile(p100_N_vichy[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}
#------------------
# Graph
#------------------

pdf(file="C:/Users/logrami/workspace/ModeleDynamiquePop/script/lateX/illustrations/2016/100poutes_TotalReturns_proj20years_2016_01_20.pdf")#,width=800,height=800)

plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+20+0.5),xlab="Années",ylim=c(0,9000),ylab="Retours à Vichy",main="Projection à 20 ans sans repeuplement - Amélioration à la montaison \n et à la dévalaison à Poutès à hauteur de 100%",cex.lab=1.2)
# trace l'axe des ordonnées
axis(2,at = c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),labels=c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),cex.axis = 1,las = 1,lwd=2,col = "black")
# trace l'axe des abscisses
axis(1,at = c(1,6,16,26,T,T+10,T+20),
		labels=c(1975,1980,1990,2000,1974+T,1974+T+10,1974+T+20),
		cex.axis = 1,las = 1,lwd=2,col = "black")
for(i in 3:30){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_real_q[i,5],i+0.15,N_vichy_real_q[i,5])
	segments(i,N_vichy_real_q[i,4],i,N_vichy_real_q[i,5])
	#5%
	segments(i-0.15,N_vichy_real_q[i,1],i+0.15,N_vichy_real_q[i,1])
	segments(i,N_vichy_real_q[i,2],i,N_vichy_real_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_real_q[i,2],N_vichy_real_q[i,2],N_vichy_real_q[i,4],N_vichy_real_q[i,4]),col="light grey")
	#median
	segments(i-0.3,N_vichy_real_q[i,3],i+0.3,N_vichy_real_q[i,3])
}
data_vichy=c(
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,393,267,515,
		380,400,541,1238,NA,#662,
		510,950,572,421,491,
		227,755,861,819,595)
points(x=seq(23,T,1),data_vichy[23:T],pch=16)

for(i in (T+1):(T+20)){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_proj_q[i,5],i+0.15,N_vichy_proj_q[i,5])
	segments(i,N_vichy_proj_q[i,4],i,N_vichy_proj_q[i,5])
	#5%
	segments(i-0.15,N_vichy_proj_q[i,1],i+0.15,N_vichy_proj_q[i,1])
	segments(i,N_vichy_proj_q[i,2],i,N_vichy_proj_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_proj_q[i,2],N_vichy_proj_q[i,2],N_vichy_proj_q[i,4],N_vichy_proj_q[i,4]),col="orange")
	#median
	segments(i-0.3,N_vichy_proj_q[i,3],i+0.3,N_vichy_proj_q[i,3])
}
dev.off()

under_10_vichy=array(0,dim=c(8000,20))
under_50_vichy=array(0,dim=c(8000,20))
under_100_vichy=array(0,dim=c(8000,20))
under_250_vichy=array(0,dim=c(8000,20))
under_500_vichy=array(0,dim=c(8000,20))


for (t in (T+1):(T+20)){
	
	for (i in 1:5000){
		if(p100_N_vichy[i,t] < 10){under_10_vichy[i,t-T]=1}  
		if(p100_N_vichy[i,t] < 50){under_50_vichy[i,t-T]=1}
		if(p100_N_vichy[i,t] < 100){under_100_vichy[i,t-T]=1}
		if(p100_N_vichy[i,t] < 250){under_250_vichy[i,t-T]=1}
		if(p100_N_vichy[i,t] < 500){under_500_vichy[i,t-T]=1}
		
	}
}


p100_p_under_10_vichy=rep(0,20)
p100_p_under_50_vichy=rep(0,20)
p100_p_under_100_vichy=rep(0,20)
p100_p_under_250_vichy=rep(0,20)
p100_p_under_500_vichy=rep(0,20)


for (t in 1:20){
	p100_p_under_10_vichy[t]=mean(under_10_vichy[,t])
	p100_p_under_50_vichy[t]=mean(under_50_vichy[,t])
	p100_p_under_100_vichy[t]=mean(under_100_vichy[,t])
	p100_p_under_250_vichy[t]=mean(under_250_vichy[,t])
	p100_p_under_500_vichy[t]=mean(under_500_vichy[,t])
	
}

pdf(file="C:/Users/logrami/workspace/ModeleDynamiquePop/script/lateX/illustrations/2016/100poutes_Threshold_2016_01_20.pdf")#,width=800,height=800)

par(mfrow=c(1,1),mar=c(4,6.1,2,0.5),cex.lab=1.4, cex.lab=1.4)

plot(1,1,type="n",axes=FALSE,xlim=c(0.5,20.5),xlab="Années",ylim=c(0,1),ylab=expression(italic(p^seuils)),cex.lab=1.5)
# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 0.9,las = 1,col = "black")
# trace l'axe des abscisses
axis(1,at = c(1,9,20),
		labels=c(1975+T,1975+T+9,1975+T+19),
		cex.axis = 0.9,las = 1,col = "black")

x=seq(1,20,1)



points(x,p100_p_under_10_vichy,col="grey85",pch=16)
segments(x[1:19],p100_p_under_10_vichy[1:19],x[2:20],p100_p_under_10_vichy[2:20],col="grey85")

points(x,p100_p_under_50_vichy,col="grey75",pch=16)
segments(x[1:19],p100_p_under_50_vichy[1:19],x[2:20],p100_p_under_50_vichy[2:20],col="grey75")

points(x,p100_p_under_100_vichy,col="grey65",pch=16)
segments(x[1:19],p100_p_under_100_vichy[1:19],x[2:20],p100_p_under_100_vichy[2:20],col="grey65")

points(x,p100_p_under_250_vichy,col="grey55",pch=16)
segments(x[1:19],p100_p_under_250_vichy[1:19],x[2:20],p100_p_under_250_vichy[2:20],col="grey55")

points(x,p100_p_under_500_vichy,col="grey45",pch=16)
segments(x[1:19],p100_p_under_500_vichy[1:19],x[2:20],p100_p_under_500_vichy[2:20],col="grey45")


legend(15,1,legend=c(expression(p^seuils < 500),expression(p^seuils < 250),expression(p^seuils < 100),expression(p^seuils < 50),expression(p^seuils < 10)),
		pch=c(16,16,16,16,16),col=c("grey45","grey55","grey65","grey75","grey85"),bty="n" )


dev.off()
}
@



\FloatBarrier

\subsection{Projection à 20 ans avec une amélioration progressive du taux de transition entre le tacon 0+ et l'adulte}
\label{res_survie}

\subsubsection{Amélioration jusqu'à atteindre 50\% du niveau initial}

<<Retour_20ans_survivalImprov50, echo=FALSE, eval=TRUE, results=hide>>=

if (chunk_true==1){
	
#On récupère les données après lancement du script PROJECTION MODELE WITHOUT STOCKING + SURVIVAL IMPROVED
load("C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/2016_01_20_AmeliorationSurvie50_2016_03_14.RData")
#============================
# PROJECTION SUR LES 20 ANS 
#============================
#==========================================
# CHAP : Figure : TotalReturns_proj20years
#==========================================

#Renomme N_vichy pour pouvoir faire calcul dans sweave sans que ça reste sur la dernière valeur si je relance le script
s50_N_vichy<-N_vichy
# Graph projection 20 years
bugs_N_vichy_real=read.coda(str_c(datawd,"2016_01_20_Standard_thin200/simulation/N_vichy_realCODAchain1.txt"),str_c(datawd,"2016_01_20_Standard_thin200/simulation/N_vichy_realCODAindex.txt"))
N_vichy_real_q=array(NA,dim=c(44,5))#44 car il y a 17 année de suivi station (soit T+20 - 16)

#Attention à l'année 30 estimation des passages Vichy car année jugée incomplète
for (t in 1:22){
	N_vichy_real_q[t,]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}
for(t in 23:23){
	N_vichy_real_q[(t+7),]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}

#N_vichy_proj_q=array(0,dim=c(43,5))
N_vichy_proj_q=array(0,dim=c(T+20,5))
for (t in (T+1):(T+20)){
	N_vichy_proj_q[t,]=quantile(s50_N_vichy[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}
#------------------
# Graph
#------------------

pdf(file="C:/Users/logrami/workspace/ModeleDynamiquePop/script/lateX/illustrations/2016/50ImprovementSurvival_TotalReturns_proj20years_2016_03_14.pdf")#,width=800,height=800)

plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+20+0.5),xlab="Années",ylim=c(0,9000),ylab="Retours à Vichy",main="Projection à 20 ans sans repeuplement - Amélioration de la survie \n jusqu'à 50% du taux de survie initial",cex.lab=1.2)
# trace l'axe des ordonnées
axis(2,at = c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),labels=c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),cex.axis = 1,las = 1,lwd=2,col = "black")
# trace l'axe des abscisses
axis(1,at = c(1,6,16,26,T,46,T+20),
		labels=c(1975,1980,1990,2000,2013,2020,2034),
		cex.axis = 1,las = 1,lwd=2,col = "black")
for(i in 3:30){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_real_q[i,5],i+0.15,N_vichy_real_q[i,5])
	segments(i,N_vichy_real_q[i,4],i,N_vichy_real_q[i,5])
	#5%
	segments(i-0.15,N_vichy_real_q[i,1],i+0.15,N_vichy_real_q[i,1])
	segments(i,N_vichy_real_q[i,2],i,N_vichy_real_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_real_q[i,2],N_vichy_real_q[i,2],N_vichy_real_q[i,4],N_vichy_real_q[i,4]),col="light grey")
	#median
	segments(i-0.3,N_vichy_real_q[i,3],i+0.3,N_vichy_real_q[i,3])
}
data_vichy=c(
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,393,267,515,
		380,400,541,1238,NA,#662,
		510,950,572,421,491,
		227,755,861,819,595)
points(x=seq(23,T,1),data_vichy[23:T],pch=16)

for(i in (T+1):(T+20)){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_proj_q[i,5],i+0.15,N_vichy_proj_q[i,5])
	segments(i,N_vichy_proj_q[i,4],i,N_vichy_proj_q[i,5])
	#5%
	segments(i-0.15,N_vichy_proj_q[i,1],i+0.15,N_vichy_proj_q[i,1])
	segments(i,N_vichy_proj_q[i,2],i,N_vichy_proj_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_proj_q[i,2],N_vichy_proj_q[i,2],N_vichy_proj_q[i,4],N_vichy_proj_q[i,4]),col="orange")
	#median
	segments(i-0.3,N_vichy_proj_q[i,3],i+0.3,N_vichy_proj_q[i,3])
}
dev.off()

under_10_vichy=array(0,dim=c(8000,20))
under_50_vichy=array(0,dim=c(8000,20))
under_100_vichy=array(0,dim=c(8000,20))
under_250_vichy=array(0,dim=c(8000,20))
under_500_vichy=array(0,dim=c(8000,20))


for (t in (T+1):(T+20)){
	
	for (i in 1:5000){
		if(s50_N_vichy[i,t] < 10){under_10_vichy[i,t-T]=1}  
		if(s50_N_vichy[i,t] < 50){under_50_vichy[i,t-T]=1}
		if(s50_N_vichy[i,t] < 100){under_100_vichy[i,t-T]=1}
		if(s50_N_vichy[i,t] < 250){under_250_vichy[i,t-T]=1}
		if(s50_N_vichy[i,t] < 500){under_500_vichy[i,t-T]=1}
		
	}
}


s50_p_under_10_vichy=rep(0,20)
s50_p_under_50_vichy=rep(0,20)
s50_p_under_100_vichy=rep(0,20)
s50_p_under_250_vichy=rep(0,20)
s50_p_under_500_vichy=rep(0,20)


for (t in 1:20){
	s50_p_under_10_vichy[t]=mean(under_10_vichy[,t])
	s50_p_under_50_vichy[t]=mean(under_50_vichy[,t])
	s50_p_under_100_vichy[t]=mean(under_100_vichy[,t])
	s50_p_under_250_vichy[t]=mean(under_250_vichy[,t])
	s50_p_under_500_vichy[t]=mean(under_500_vichy[,t])
	
}

pdf(file="C:/Users/logrami/workspace/ModeleDynamiquePop/script/lateX/illustrations/2016/50ImprovementSurvival_Threshold_2016_03_14.pdf")#,width=800,height=800)

par(mfrow=c(1,1),mar=c(4,6.1,2,0.5),cex.lab=1.4, cex.lab=1.4)

plot(1,1,type="n",axes=FALSE,xlim=c(0.5,20.5),xlab="Années",ylim=c(0,1),ylab=expression(italic(p^seuils)),cex.lab=1.5)
# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 0.9,las = 1,col = "black")
# trace l'axe des abscisses
axis(1,at = c(1,9,20),
		labels=c(2015,2020,2034),
		cex.axis = 0.9,las = 1,col = "black")

x=seq(1,20,1)



points(x,s50_p_under_10_vichy,col="grey85",pch=16)
segments(x[1:19],s50_p_under_10_vichy[1:19],x[2:20],s50_p_under_10_vichy[2:20],col="grey85")

points(x,s50_p_under_50_vichy,col="grey75",pch=16)
segments(x[1:19],s50_p_under_50_vichy[1:19],x[2:20],s50_p_under_50_vichy[2:20],col="grey75")

points(x,s50_p_under_100_vichy,col="grey65",pch=16)
segments(x[1:19],s50_p_under_100_vichy[1:19],x[2:20],s50_p_under_100_vichy[2:20],col="grey65")

points(x,s50_p_under_250_vichy,col="grey55",pch=16)
segments(x[1:19],s50_p_under_250_vichy[1:19],x[2:20],s50_p_under_250_vichy[2:20],col="grey55")

points(x,s50_p_under_500_vichy,col="grey45",pch=16)
segments(x[1:19],s50_p_under_500_vichy[1:19],x[2:20],s50_p_under_500_vichy[2:20],col="grey45")


legend(15,1,legend=c(expression(p^seuils < 500),expression(p^seuils < 250),expression(p^seuils < 100),expression(p^seuils < 50),expression(p^seuils < 10)),
		pch=c(16,16,16,16,16),col=c("grey45","grey55","grey65","grey75","grey85"),bty="n" )


dev.off()

}
@


\FloatBarrier

\subsubsection{Amélioration jusqu'à atteindre 100\% du niveau initial}
\label{resu_surv100}
<<Retour_20ans_survivalImprov100, echo=FALSE, eval=TRUE, results=hide>>=

if (chunk_true==1){
	
#On récupère les données après lancement du script PROJECTION MODELE WITHOUT STOCKING + SURVIVAL IMPROVED
load("C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/2016_01_20_AmeliorationSurvie100_2016_03_14.RData")
#============================
# PROJECTION SUR LES 20 ANS 
#============================
#==========================================
# CHAP : Figure : TotalReturns_proj20years
#==========================================
#Renomme N_vichy pour pouvoir faire calcul dans sweave sans que ça reste sur la dernière valeur si je relance le script
s100_N_vichy<-N_vichy
# Graph projection 20 years
bugs_N_vichy_real=read.coda(str_c(datawd,"2016_01_20_Standard_thin200/simulation/N_vichy_realCODAchain1.txt"),str_c(datawd,"2016_01_20_Standard_thin200/simulation/N_vichy_realCODAindex.txt"))
N_vichy_real_q=array(NA,dim=c(44,5))#44 car il y a 17 année de suivi station (soit T+20 - 16)

#Attention à l'année 30 estimation des passages Vichy car année jugée incomplète
for (t in 1:22){
	N_vichy_real_q[t,]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}
for(t in 23:23){
	N_vichy_real_q[(t+7),]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}

#N_vichy_proj_q=array(0,dim=c(43,5))
N_vichy_proj_q=array(0,dim=c(T+20,5))
for (t in (T+1):(T+20)){
	N_vichy_proj_q[t,]=quantile(s100_N_vichy[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}
#------------------
# Graph
#------------------

pdf(file="C:/Users/logrami/workspace/ModeleDynamiquePop/script/lateX/illustrations/2016/100ImprovementSurvival_TotalReturns_proj20years_2016_03_14.pdf")#,width=800,height=800)

plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+20+0.5),xlab="Années",ylim=c(0,9000),ylab="Retours à Vichy",main="Projection à 20 ans sans repeuplement - Amélioration de la survie  \n jusqu'à l'atteinte de son niveau initial",cex.lab=1.2)
# trace l'axe des ordonnées
axis(2,at = c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),labels=c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),cex.axis = 1,las = 1,lwd=2,col = "black")
# trace l'axe des abscisses
axis(1,at = c(1,6,16,26,T,46,T+20),
		labels=c(1975,1980,1990,2000,2013,2020,1974+T+20),
		cex.axis = 1,las = 1,lwd=2,col = "black")
for(i in 3:30){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_real_q[i,5],i+0.15,N_vichy_real_q[i,5])
	segments(i,N_vichy_real_q[i,4],i,N_vichy_real_q[i,5])
	#5%
	segments(i-0.15,N_vichy_real_q[i,1],i+0.15,N_vichy_real_q[i,1])
	segments(i,N_vichy_real_q[i,2],i,N_vichy_real_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_real_q[i,2],N_vichy_real_q[i,2],N_vichy_real_q[i,4],N_vichy_real_q[i,4]),col="light grey")
	#median
	segments(i-0.3,N_vichy_real_q[i,3],i+0.3,N_vichy_real_q[i,3])
}
data_vichy=c(
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,393,267,515,
		380,400,541,1238,NA,#662,
		510,950,572,421,491,
		227,755,861,819,595)
points(x=seq(23,T,1),data_vichy[23:T],pch=16)

for(i in (T+1):(T+20)){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_proj_q[i,5],i+0.15,N_vichy_proj_q[i,5])
	segments(i,N_vichy_proj_q[i,4],i,N_vichy_proj_q[i,5])
	#5%
	segments(i-0.15,N_vichy_proj_q[i,1],i+0.15,N_vichy_proj_q[i,1])
	segments(i,N_vichy_proj_q[i,2],i,N_vichy_proj_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_proj_q[i,2],N_vichy_proj_q[i,2],N_vichy_proj_q[i,4],N_vichy_proj_q[i,4]),col="orange")
	#median
	segments(i-0.3,N_vichy_proj_q[i,3],i+0.3,N_vichy_proj_q[i,3])
}
dev.off()

under_10_vichy=array(0,dim=c(8000,20))
under_50_vichy=array(0,dim=c(8000,20))
under_100_vichy=array(0,dim=c(8000,20))
under_250_vichy=array(0,dim=c(8000,20))
under_500_vichy=array(0,dim=c(8000,20))


for (t in (T+1):(T+20)){
	
	for (i in 1:5000){
		if(s100_N_vichy[i,t] < 10){under_10_vichy[i,t-T]=1}  
		if(s100_N_vichy[i,t] < 50){under_50_vichy[i,t-T]=1}
		if(s100_N_vichy[i,t] < 100){under_100_vichy[i,t-T]=1}
		if(s100_N_vichy[i,t] < 250){under_250_vichy[i,t-T]=1}
		if(s100_N_vichy[i,t] < 500){under_500_vichy[i,t-T]=1}
		
	}
}


s100_p_under_10_vichy=rep(0,20)
s100_p_under_50_vichy=rep(0,20)
s100_p_under_100_vichy=rep(0,20)
s100_p_under_250_vichy=rep(0,20)
s100_p_under_500_vichy=rep(0,20)


for (t in 1:20){
	s100_p_under_10_vichy[t]=mean(under_10_vichy[,t])
	s100_p_under_50_vichy[t]=mean(under_50_vichy[,t])
	s100_p_under_100_vichy[t]=mean(under_100_vichy[,t])
	s100_p_under_250_vichy[t]=mean(under_250_vichy[,t])
	s100_p_under_500_vichy[t]=mean(under_500_vichy[,t])
	
}

pdf(file="C:/Users/logrami/workspace/ModeleDynamiquePop/script/lateX/illustrations/2016/100ImprovementSurvival_Threshold_2016_03_14.pdf")#,width=800,height=800)

par(mfrow=c(1,1),mar=c(4,6.1,2,0.5),cex.lab=1.4, cex.lab=1.4)

plot(1,1,type="n",axes=FALSE,xlim=c(0.5,20.5),xlab="Années",ylim=c(0,1),ylab=expression(italic(p^seuils)),cex.lab=1.5)
# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 0.9,las = 1,col = "black")
# trace l'axe des abscisses
axis(1,at = c(1,9,20),
		labels=c(2014,2020,1974+T+20),
		cex.axis = 0.9,las = 1,col = "black")

x=seq(1,20,1)



points(x,s100_p_under_10_vichy,col="grey85",pch=16)
segments(x[1:19],s100_p_under_10_vichy[1:19],x[2:20],s100_p_under_10_vichy[2:20],col="grey85")

points(x,s100_p_under_50_vichy,col="grey75",pch=16)
segments(x[1:19],s100_p_under_50_vichy[1:19],x[2:20],s100_p_under_50_vichy[2:20],col="grey75")

points(x,s100_p_under_100_vichy,col="grey65",pch=16)
segments(x[1:19],s100_p_under_100_vichy[1:19],x[2:20],s100_p_under_100_vichy[2:20],col="grey65")

points(x,s100_p_under_250_vichy,col="grey55",pch=16)
segments(x[1:19],s100_p_under_250_vichy[1:19],x[2:20],s100_p_under_250_vichy[2:20],col="grey55")

points(x,s100_p_under_500_vichy,col="grey45",pch=16)
segments(x[1:19],s100_p_under_500_vichy[1:19],x[2:20],s100_p_under_500_vichy[2:20],col="grey45")


legend(15,1,legend=c(expression(p^seuils < 500),expression(p^seuils < 250),expression(p^seuils < 100),expression(p^seuils < 50),expression(p^seuils < 10)),
		pch=c(16,16,16,16,16),col=c("grey45","grey55","grey65","grey75","grey85"),bty="n" )


dev.off()
}
@



\subsection{Projection à 20 ans avec suppression des impacts à la dévalaison dans les ouvrages hydroélectriques}
\label{res_deval}

Cette section présente d'une part, les projections réalisées
en répartissant les juvéniles du secteur 1 sur l'ensemble des axes de ce secteur
(Allier en aval de Langeac, Alagnon et Dore) et d'autre part, les projections
réalisées sous l'hypothèse d'une production nulle en juvénile sur la Dore
(autrement dit, les juvéniles produits dans le secteur 1 sont répartis
uniquement entre l'Allier en aval de Langeac et l'Alagnon)(cf. section \ref{scenario_deval}).
Dans chacune des sous-parties suivantes, les résultats sont présentés en
fonction de l'hypothèse de répartition des juvéniles réalisée :
\begin{itemize}
  \item au \textit{prorata} des surfaces productives disponibles,
  \item au \textit{prorata} des surfaces productives disponibles pondéré par la
  productivité de chacun des axes.
\end{itemize}

\subsubsection{Modélisation sur l'ensemble des axes du secteur 1 (Allier en aval
de Langeac, Alagnon et Dore)} 

%La suppression des mortalités liées à la dévalaison par les turbines des
%ouvrages hydroélectriques permet d'obtenir une population quasiment stable à
%l'horizon de 20 ans (figure \ref{fig_retour_20ans_deval_Surf} et 
%\ref{fig_retour_20ans_deval}).

<<Retour_20ans_Deval100_surf, echo=FALSE, eval=FALSE, results=hide>>=
#On ne le lance pas car ancien modèle sans ajout de rho_poutes
if (chunk_true==1){

	###### MODELISATION AVEC REPARTITION DES JUVENILES AU PRORATA DES SURFACES DISPONIBLES ET PRISE EN COMPTE DE LA PRODUCTIVITE DES RIVIERES
#On récupère les données après lancement du script SimulationMortalitéDevalaison
#load("C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/2016_01_20_OuvertureDevalaison_2016_03_14.RData")
load("C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/2016_01_20_Devalaison_ss_rho_poutes_Surf_thin200_2016_11_03.RData")
#==========================================
# CHAP : Figure : TotalReturns_proj20years
#==========================================
#Renomme N_vichy pour pouvoir faire calcul dans sweave sans que ça reste sur la dernière valeur si je relance le script
dev1_N_vichy<-N_vichy
# Graph projection 20 years
bugs_N_vichy_real=read.coda(str_c(datawd,"2016_01_20_Devalaison_Surf_thin200/simulation/N_vichy_realCODAchain1.txt"),str_c(datawd,"2016_01_20_Devalaison_Surf_thin200/simulation/N_vichy_realCODAindex.txt"))
N_vichy_real_q=array(NA,dim=c(44,5))#44 car il y a 17 année de suivi station (soit T+20 - 16)

#Attention à l'année 30 estimation des passages Vichy car année jugée incomplète
for (t in 1:22){
	N_vichy_real_q[t,]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}
for(t in 23:23){
	N_vichy_real_q[(t+7),]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}

#N_vichy_proj_q=array(0,dim=c(43,5))
N_vichy_proj_q=array(0,dim=c(T+20,5))
for (t in (T+1):(T+20)){
	N_vichy_proj_q[t,]=quantile(dev1_N_vichy[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}

#------------------
# Graph
#------------------
pdf(file=str_c(imgwd,"DevalMorta_TotalReturns_proj20years_Surf_ss_rho_poutes_2016_11_03.pdf"))#,width=8,height=8)


plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+20+0.5),xlab="Années",ylim=c(0,9000),ylab="Retour à Vichy",main="Projection à 20 ans sans repeuplement - Suppression des mortalités \n à la dévalaison dans les 11 ouvrages hydroélectriques",sub="Répartition des juvéniles au prorata des surfaces disponibles + prise en compte de la productivité des rivières",cex.sub=0.75,cex.lab=1.5)

# trace l'axe des ordonnées
axis(2,at = c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),labels=c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),cex.axis = 1.2,las = 1,lwd=2,col = "black")
# trace l'axe des abscisses
lab1=c(1975,1980,1990,2000,1974+T,1974+T+10,1974+T+20)
axis(1,at = c(1,6,16,26,T,T+10,T+20),
		labels=lab1,
		cex.axis = 1.2,las = 1,lwd=2,col = "black")


for(i in 3:30){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_real_q[i,5],i+0.15,N_vichy_real_q[i,5])
	segments(i,N_vichy_real_q[i,4],i,N_vichy_real_q[i,5])
	#5%
	segments(i-0.15,N_vichy_real_q[i,1],i+0.15,N_vichy_real_q[i,1])
	segments(i,N_vichy_real_q[i,2],i,N_vichy_real_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_real_q[i,2],N_vichy_real_q[i,2],N_vichy_real_q[i,4],N_vichy_real_q[i,4]),col="light grey")
	#median
	segments(i-0.3,N_vichy_real_q[i,3],i+0.3,N_vichy_real_q[i,3])
}


data_vichy=c(
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,393,267,515,
		380,400,541,1238,NA,#662,
		510,950,572,421,491,
		227,755,861,819,595)
points(x=seq(23,T,1),data_vichy[23:T],pch=16)

for(i in (T+1):(T+20)){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_proj_q[i,5],i+0.15,N_vichy_proj_q[i,5])
	segments(i,N_vichy_proj_q[i,4],i,N_vichy_proj_q[i,5])
	#5%
	segments(i-0.15,N_vichy_proj_q[i,1],i+0.15,N_vichy_proj_q[i,1])
	segments(i,N_vichy_proj_q[i,2],i,N_vichy_proj_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_proj_q[i,2],N_vichy_proj_q[i,2],N_vichy_proj_q[i,4],N_vichy_proj_q[i,4]),col="orange")
	#median
	segments(i-0.3,N_vichy_proj_q[i,3],i+0.3,N_vichy_proj_q[i,3])
}


dev.off()

#==================================
# CHAP : Figure : Threshold
#==================================
#bugs_N_vichy=read.coda("N_vichyCODAchain1.txt","N_vichyCODAindex.txt")	

under_10_vichy=array(0,dim=c(8000,20))
under_50_vichy=array(0,dim=c(8000,20))
under_100_vichy=array(0,dim=c(8000,20))
under_250_vichy=array(0,dim=c(8000,20))
under_500_vichy=array(0,dim=c(8000,20))


for (t in (T+1):(T+20)){
	
	for (i in 1:5000){
		if(dev1_N_vichy[i,t] < 10){under_10_vichy[i,t-T]=1}  
		if(dev1_N_vichy[i,t] < 50){under_50_vichy[i,t-T]=1}
		if(dev1_N_vichy[i,t] < 100){under_100_vichy[i,t-T]=1}
		if(dev1_N_vichy[i,t] < 250){under_250_vichy[i,t-T]=1}
		if(dev1_N_vichy[i,t] < 500){under_500_vichy[i,t-T]=1}
		
	}
}


dev1_p_under_10_vichy=rep(0,20)
dev1_p_under_50_vichy=rep(0,20)
dev1_p_under_100_vichy=rep(0,20)
dev1_p_under_250_vichy=rep(0,20)
dev1_p_under_500_vichy=rep(0,20)


for (t in 1:20){
	dev1_p_under_10_vichy[t]=mean(under_10_vichy[,t])
	dev1_p_under_50_vichy[t]=mean(under_50_vichy[,t])
	dev1_p_under_100_vichy[t]=mean(under_100_vichy[,t])
	dev1_p_under_250_vichy[t]=mean(under_250_vichy[,t])
	dev1_p_under_500_vichy[t]=mean(under_500_vichy[,t])
	
}

#------------------------
# Graph
#------------------------
pdf(file=str_c(imgwd,"DevalaisonMorta_Threshold_Surf_ss_rho_poutes_2016_11_03.pdf"))#,width=8,height=8)

par(mfrow=c(1,1),mar=c(4,6.1,2,0.5),cex.lab=1.4, cex.lab=1.4)

plot(1,1,type="n",axes=FALSE,xlim=c(0.5,20.5),xlab="Années",ylim=c(0,1),ylab=expression(italic(p^threshold)),main="",sub="Répartition des juvéniles au prorata des surfaces disponibles + prise en compte de la productivité des rivières",cex.sub=0.75)

# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 0.9,las = 1,col = "black")
# trace l'axe des abscisses
lab2=c(1975+T,1975+T+9,1975+T+19)
axis(1,at = c(1,10,20),
		labels=lab2,
		cex.axis = 0.9,las = 1,col = "black")

x=seq(1,20,1)



points(x,dev1_p_under_10_vichy,col="grey85",pch=16)
segments(x[1:19],dev1_p_under_10_vichy[1:19],x[2:20],dev1_p_under_10_vichy[2:20],col="grey85")

points(x,dev1_p_under_50_vichy,col="grey75",pch=16)
segments(x[1:19],dev1_p_under_50_vichy[1:19],x[2:20],dev1_p_under_50_vichy[2:20],col="grey75")

points(x,dev1_p_under_100_vichy,col="grey65",pch=16)
segments(x[1:19],dev1_p_under_100_vichy[1:19],x[2:20],dev1_p_under_100_vichy[2:20],col="grey65")

points(x,dev1_p_under_250_vichy,col="grey55",pch=16)
segments(x[1:19],dev1_p_under_250_vichy[1:19],x[2:20],dev1_p_under_250_vichy[2:20],col="grey55")

points(x,dev1_p_under_500_vichy,col="grey45",pch=16)
segments(x[1:19],dev1_p_under_500_vichy[1:19],x[2:20],dev1_p_under_500_vichy[2:20],col="grey45")


legend(15,1,legend=c(expression(p^treshold < 500),expression(p^treshold < 250),expression(p^treshold < 100),expression(p^treshold < 50),expression(p^treshold < 10)),
		pch=c(16,16,16,16,16),
		col=c("grey45","grey55","grey65","grey75","grey85"),
		bty="n" )


dev.off()
	
	
	
}
@

<<Retour_20ans_Deval100_rho_poutes_Surf, echo=FALSE, eval=TRUE, results=hide>>=

if (chunk_true==1){

	###### MODELISATION AVEC REPARTITION DES JUVENILES AU PRORATA DES SURFACES DISPONIBLES
#On récupère les données après lancement du script SimulationMortalitéDevalaison
#load("C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/2016_11_03_Devalaisonac_rho_poutes_Surf_thin200.RData")
load("C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/2016_07_01_Devalaisonac_rho_poutes_Surf_2016_12_21.RData")
#==========================================
# CHAP : Figure : TotalReturns_proj20years
#==========================================
#Renomme N_vichy pour pouvoir faire calcul dans sweave sans que ça reste sur la dernière valeur si je relance le script
dev_s_N_vichy<-N_vichy
# Graph projection 20 years
bugs_N_vichy_real=read.coda(str_c(datawd,"2016_11_03_Devalaison_rho_poutes_Surf_thin200/simulation/N_vichy_realCODAchain1.txt"),str_c(datawd,"2016_11_03_Devalaison_rho_poutes_Surf_thin200/simulation/N_vichy_realCODAindex.txt"))
N_vichy_real_q=array(NA,dim=c(44,5))#44 car il y a 17 année de suivi station (soit T+20 - 16)

#Attention à l'année 30 estimation des passages Vichy car année jugée incomplète
for (t in 1:22){
	N_vichy_real_q[t,]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}
for(t in 23:23){
	N_vichy_real_q[(t+7),]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}

#N_vichy_proj_q=array(0,dim=c(43,5))
N_vichy_proj_q=array(0,dim=c(T+20,5))
for (t in (T+1):(T+20)){
	N_vichy_proj_q[t,]=quantile(dev_s_N_vichy[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}

#------------------
# Graph
#------------------
pdf(file=str_c(imgwd,"DevalMorta_TotalReturns_proj20years_Surf_rhopoutes_2016_11_03.pdf"))#,width=8,height=8)


plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+20+0.5),xlab="Années",ylim=c(0,9000),ylab="Retour à Vichy",main="Projection à 20 ans sans repeuplement - Suppression des mortalités \n à la dévalaison dans les 11 ouvrages hydroélectriques",sub="Répartition des juvéniles au prorata des surfaces disponibles",cex.sub=0.75,cex.lab=1.5)

# trace l'axe des ordonnées
axis(2,at = c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),labels=c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),cex.axis = 1.2,las = 1,lwd=2,col = "black")
# trace l'axe des abscisses
lab1=c(1975,1980,1990,2000,1974+T,1974+T+10,1974+T+20)
axis(1,at = c(1,6,16,26,T,T+10,T+20),
		labels=lab1,
		cex.axis = 1.2,las = 1,lwd=2,col = "black")


for(i in 3:30){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_real_q[i,5],i+0.15,N_vichy_real_q[i,5])
	segments(i,N_vichy_real_q[i,4],i,N_vichy_real_q[i,5])
	#5%
	segments(i-0.15,N_vichy_real_q[i,1],i+0.15,N_vichy_real_q[i,1])
	segments(i,N_vichy_real_q[i,2],i,N_vichy_real_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_real_q[i,2],N_vichy_real_q[i,2],N_vichy_real_q[i,4],N_vichy_real_q[i,4]),col="light grey")
	#median
	segments(i-0.3,N_vichy_real_q[i,3],i+0.3,N_vichy_real_q[i,3])
}


data_vichy=c(
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,393,267,515,
		380,400,541,1238,NA,#662,
		510,950,572,421,491,
		227,755,861,819,595)
points(x=seq(23,T,1),data_vichy[23:T],pch=16)

for(i in (T+1):(T+20)){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_proj_q[i,5],i+0.15,N_vichy_proj_q[i,5])
	segments(i,N_vichy_proj_q[i,4],i,N_vichy_proj_q[i,5])
	#5%
	segments(i-0.15,N_vichy_proj_q[i,1],i+0.15,N_vichy_proj_q[i,1])
	segments(i,N_vichy_proj_q[i,2],i,N_vichy_proj_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_proj_q[i,2],N_vichy_proj_q[i,2],N_vichy_proj_q[i,4],N_vichy_proj_q[i,4]),col="orange")
	#median
	segments(i-0.3,N_vichy_proj_q[i,3],i+0.3,N_vichy_proj_q[i,3])
}


dev.off()

#==================================
# CHAP : Figure : Threshold
#==================================
#bugs_N_vichy=read.coda("N_vichyCODAchain1.txt","N_vichyCODAindex.txt")	

under_10_vichy=array(0,dim=c(8000,20))
under_50_vichy=array(0,dim=c(8000,20))
under_100_vichy=array(0,dim=c(8000,20))
under_250_vichy=array(0,dim=c(8000,20))
under_500_vichy=array(0,dim=c(8000,20))


for (t in (T+1):(T+20)){
	
	for (i in 1:5000){
		if(dev_s_N_vichy[i,t] < 10){under_10_vichy[i,t-T]=1}  
		if(dev_s_N_vichy[i,t] < 50){under_50_vichy[i,t-T]=1}
		if(dev_s_N_vichy[i,t] < 100){under_100_vichy[i,t-T]=1}
		if(dev_s_N_vichy[i,t] < 250){under_250_vichy[i,t-T]=1}
		if(dev_s_N_vichy[i,t] < 500){under_500_vichy[i,t-T]=1}
		
	}
}


dev_s_p_under_10_vichy=rep(0,20)
dev_s_p_under_50_vichy=rep(0,20)
dev_s_p_under_100_vichy=rep(0,20)
dev_s_p_under_250_vichy=rep(0,20)
dev_s_p_under_500_vichy=rep(0,20)


for (t in 1:20){
	dev_s_p_under_10_vichy[t]=mean(under_10_vichy[,t])
	dev_s_p_under_50_vichy[t]=mean(under_50_vichy[,t])
	dev_s_p_under_100_vichy[t]=mean(under_100_vichy[,t])
	dev_s_p_under_250_vichy[t]=mean(under_250_vichy[,t])
	dev_s_p_under_500_vichy[t]=mean(under_500_vichy[,t])
	
}

#------------------------
# Graph
#------------------------
pdf(file=str_c(imgwd,"DevalaisonMorta_Threshold_Surf_rhopoutes_2016_11_03.pdf"))#,width=8,height=8)

par(mfrow=c(1,1),mar=c(4,6.1,2,0.5),cex.lab=1.4, cex.lab=1.4)

plot(1,1,type="n",axes=FALSE,xlim=c(0.5,20.5),xlab="Années",ylim=c(0,1),ylab=expression(italic(p^threshold)),main="",sub="Répartition des juvéniles au prorata des surfaces disponibles",cex.sub=0.75)

# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 0.9,las = 1,col = "black")
# trace l'axe des abscisses
lab2=c(1975+T,1975+T+9,1975+T+19)
axis(1,at = c(1,10,20),
		labels=lab2,
		cex.axis = 0.9,las = 1,col = "black")

x=seq(1,20,1)



points(x,dev_s_p_under_10_vichy,col="grey85",pch=16)
segments(x[1:19],dev_s_p_under_10_vichy[1:19],x[2:20],dev_s_p_under_10_vichy[2:20],col="grey85")

points(x,dev_s_p_under_50_vichy,col="grey75",pch=16)
segments(x[1:19],dev_s_p_under_50_vichy[1:19],x[2:20],dev_s_p_under_50_vichy[2:20],col="grey75")

points(x,dev_s_p_under_100_vichy,col="grey65",pch=16)
segments(x[1:19],dev_s_p_under_100_vichy[1:19],x[2:20],dev_s_p_under_100_vichy[2:20],col="grey65")

points(x,dev_s_p_under_250_vichy,col="grey55",pch=16)
segments(x[1:19],dev_s_p_under_250_vichy[1:19],x[2:20],dev_s_p_under_250_vichy[2:20],col="grey55")

points(x,dev_s_p_under_500_vichy,col="grey45",pch=16)
segments(x[1:19],dev_s_p_under_500_vichy[1:19],x[2:20],dev_s_p_under_500_vichy[2:20],col="grey45")


legend(15,1,legend=c(expression(p^treshold < 500),expression(p^treshold < 250),expression(p^treshold < 100),expression(p^treshold < 50),expression(p^treshold < 10)),
		pch=c(16,16,16,16,16),
		col=c("grey45","grey55","grey65","grey75","grey85"),
		bty="n" )


dev.off()
	
	
	
}
@

<<Retour_20ans_Deval100_rho_poutes_Surf&Prod, echo=FALSE, eval=TRUE, results=hide>>=

if (chunk_true==1){

	###### MODELISATION AVEC REPARTITION DES JUVENILES AU PRORATA DES SURFACES DISPONIBLES ET PRISE EN COMPTE DE LA PRODUCTIVITE DES RIVIERES
#On récupère les données après lancement du script SimulationMortalitéDevalaison
#load("C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/2016_01_20_DevalaisonAvecPoutes_Surf&Prod_2016_04_08.RData")
load("C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/2016_07_01_Devalaisonac_rho_poutes_Surf&Prod_2016_12_20.RData")

#==========================================
# CHAP : Figure : TotalReturns_proj20years
#==========================================
#Renomme N_vichy pour pouvoir faire calcul dans sweave sans que ça reste sur la dernière valeur si je relance le script
dev_N_vichy<-N_vichy
# Graph projection 20 years
bugs_N_vichy_real=read.coda(str_c(datawd,"2016_01_20_Devalaison_AvecRho_poutes/simulation/N_vichy_realCODAchain1.txt"),str_c(datawd,"2016_01_20_Devalaison_AvecRho_poutes/simulation/N_vichy_realCODAindex.txt"))
N_vichy_real_q=array(NA,dim=c(44,5))#44 car il y a 17 année de suivi station (soit T+20 - 16)

#Attention à l'année 30 estimation des passages Vichy car année jugée incomplète
for (t in 1:22){
	N_vichy_real_q[t,]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}
for(t in 23:23){
	N_vichy_real_q[(t+7),]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}

#N_vichy_proj_q=array(0,dim=c(43,5))
N_vichy_proj_q=array(0,dim=c(T+20,5))
for (t in (T+1):(T+20)){
	N_vichy_proj_q[t,]=quantile(dev_N_vichy[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}

#------------------
# Graph
#------------------
pdf(file=str_c(imgwd,"DevalMorta_TotalReturns_proj20years_AvecRhoPoutes_2016_04_08.pdf"))#,width=8,height=8)


plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+20+0.5),xlab="Années",ylim=c(0,9000),ylab="Retour à Vichy",main="Projection à 20 ans sans repeuplement - Suppression des mortalités \n à la dévalaison dans les 11 ouvrages hydroélectriques",sub="Répartition des juvéniles au prorata des surfaces disponibles + prise en compte de la productivité des rivières",cex.sub=0.75,cex.lab=1.5)

# trace l'axe des ordonnées
axis(2,at = c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),labels=c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),cex.axis = 1.2,las = 1,lwd=2,col = "black")
# trace l'axe des abscisses
lab1=c(1975,1980,1990,2000,1974+T,1974+T+10,1974+T+20)
axis(1,at = c(1,6,16,26,T,T+10,T+20),
		labels=lab1,
		cex.axis = 1.2,las = 1,lwd=2,col = "black")


for(i in 3:30){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_real_q[i,5],i+0.15,N_vichy_real_q[i,5])
	segments(i,N_vichy_real_q[i,4],i,N_vichy_real_q[i,5])
	#5%
	segments(i-0.15,N_vichy_real_q[i,1],i+0.15,N_vichy_real_q[i,1])
	segments(i,N_vichy_real_q[i,2],i,N_vichy_real_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_real_q[i,2],N_vichy_real_q[i,2],N_vichy_real_q[i,4],N_vichy_real_q[i,4]),col="light grey")
	#median
	segments(i-0.3,N_vichy_real_q[i,3],i+0.3,N_vichy_real_q[i,3])
}


data_vichy=c(
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,393,267,515,
		380,400,541,1238,NA,#662,
		510,950,572,421,491,
		227,755,861,819,595)
points(x=seq(23,T,1),data_vichy[23:T],pch=16)

for(i in (T+1):(T+20)){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_proj_q[i,5],i+0.15,N_vichy_proj_q[i,5])
	segments(i,N_vichy_proj_q[i,4],i,N_vichy_proj_q[i,5])
	#5%
	segments(i-0.15,N_vichy_proj_q[i,1],i+0.15,N_vichy_proj_q[i,1])
	segments(i,N_vichy_proj_q[i,2],i,N_vichy_proj_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_proj_q[i,2],N_vichy_proj_q[i,2],N_vichy_proj_q[i,4],N_vichy_proj_q[i,4]),col="orange")
	#median
	segments(i-0.3,N_vichy_proj_q[i,3],i+0.3,N_vichy_proj_q[i,3])
}


dev.off()

#==================================
# CHAP : Figure : Threshold
#==================================
#bugs_N_vichy=read.coda("N_vichyCODAchain1.txt","N_vichyCODAindex.txt")	

under_10_vichy=array(0,dim=c(8000,20))
under_50_vichy=array(0,dim=c(8000,20))
under_100_vichy=array(0,dim=c(8000,20))
under_250_vichy=array(0,dim=c(8000,20))
under_500_vichy=array(0,dim=c(8000,20))


for (t in (T+1):(T+20)){
	
	for (i in 1:5000){
		if(dev_N_vichy[i,t] < 10){under_10_vichy[i,t-T]=1}  
		if(dev_N_vichy[i,t] < 50){under_50_vichy[i,t-T]=1}
		if(dev_N_vichy[i,t] < 100){under_100_vichy[i,t-T]=1}
		if(dev_N_vichy[i,t] < 250){under_250_vichy[i,t-T]=1}
		if(dev_N_vichy[i,t] < 500){under_500_vichy[i,t-T]=1}
		
	}
}


dev_p_under_10_vichy=rep(0,20)
dev_p_under_50_vichy=rep(0,20)
dev_p_under_100_vichy=rep(0,20)
dev_p_under_250_vichy=rep(0,20)
dev_p_under_500_vichy=rep(0,20)


for (t in 1:20){
	dev_p_under_10_vichy[t]=mean(under_10_vichy[,t])
	dev_p_under_50_vichy[t]=mean(under_50_vichy[,t])
	dev_p_under_100_vichy[t]=mean(under_100_vichy[,t])
	dev_p_under_250_vichy[t]=mean(under_250_vichy[,t])
	dev_p_under_500_vichy[t]=mean(under_500_vichy[,t])
	
}

#------------------------
# Graph
#------------------------
pdf(file=str_c(imgwd,"DevalaisonMorta_Threshold_AvecRhoPoutes_2016_04_08.pdf"))#,width=8,height=8)

par(mfrow=c(1,1),mar=c(4,6.1,2,0.5),cex.lab=1.4, cex.lab=1.4)

plot(1,1,type="n",axes=FALSE,xlim=c(0.5,20.5),xlab="Années",ylim=c(0,1),ylab=expression(italic(p^threshold)),main="",sub="Répartition des juvéniles au prorata des surfaces disponibles + prise en compte de la productivité des rivières",cex.sub=0.75)

# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 0.9,las = 1,col = "black")
# trace l'axe des abscisses
lab2=c(1975+T,1975+T+9,1975+T+19)
axis(1,at = c(1,10,20),
		labels=lab2,
		cex.axis = 0.9,las = 1,col = "black")

x=seq(1,20,1)



points(x,dev_p_under_10_vichy,col="grey85",pch=16)
segments(x[1:19],dev_p_under_10_vichy[1:19],x[2:20],dev_p_under_10_vichy[2:20],col="grey85")

points(x,dev_p_under_50_vichy,col="grey75",pch=16)
segments(x[1:19],dev_p_under_50_vichy[1:19],x[2:20],dev_p_under_50_vichy[2:20],col="grey75")

points(x,dev_p_under_100_vichy,col="grey65",pch=16)
segments(x[1:19],dev_p_under_100_vichy[1:19],x[2:20],dev_p_under_100_vichy[2:20],col="grey65")

points(x,dev_p_under_250_vichy,col="grey55",pch=16)
segments(x[1:19],dev_p_under_250_vichy[1:19],x[2:20],dev_p_under_250_vichy[2:20],col="grey55")

points(x,dev_p_under_500_vichy,col="grey45",pch=16)
segments(x[1:19],dev_p_under_500_vichy[1:19],x[2:20],dev_p_under_500_vichy[2:20],col="grey45")


legend(15,1,legend=c(expression(p^treshold < 500),expression(p^treshold < 250),expression(p^treshold < 100),expression(p^treshold < 50),expression(p^treshold < 10)),
		pch=c(16,16,16,16,16),
		col=c("grey45","grey55","grey65","grey75","grey85"),
		bty="n" )


dev.off()
	
	
	
}
@

\paragraph*{Répartition des juvéniles au \textit{prorata} des surfaces
disponibles} 
Dans l'hypothèse d'une répartition stricte des juvéniles au \textit{prorata} des
surfaces disponibles, nous obtenons les résultats suivants :



\paragraph*{Répartition des juvéniles au \textit{prorata} des surfaces
disponibles, avec prise en compte de la productivité des rivières} Dans
l'hypothèse d'une répartition des juvéniles au \textit{prorata} des surfaces productives disponibles pondérées par la productivité des rivières,
nous obtenons les résultats suivants pour la projection à 20 ans avec arrêt
des déversements et suppression des impacts à la dévalaison dans les 11
ouvrages hydroélectriques :







\subsubsection{Modélisation sous l'hypothèse d'une production nulle en
juvéniles de la Dore}

<<Retour_20ans_Deval_ssDore, echo=FALSE, eval=TRUE, results=hide>>=

if (chunk_true==1){
	#### REPARTITION DES JUVENILES AU PRORATA DES SURFACES + PRISE EN COMPTE DE LA PRODUCTIVITE DES COURS D'EAU
#On récupère les données après lancement du script SimulationMortalitéDevalaison partie
#load("C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/2016_01_20_OuvertureDevalaison_ssDore_2016_03_17.RData")
load("C:/Users/LOGRAMI/workspace/ModeleDynamiquePop/2016_07_01_Devalaisonac_rho_poutes_Surf&prod_0_dore_2016_12_21.RData")
	
#==========================================
# CHAP : Figure : TotalReturns_proj20years
#==========================================
#Renomme N_vichy pour pouvoir faire calcul dans sweave sans que ça reste sur la dernière valeur si je relance le script
dev_sd_N_vichy<-N_vichy

# Graph projection 20 years
bugs_N_vichy_real=read.coda(str_c(datawd,"2016_01_18_ss_Dore/simulation/N_vichy_realCODAchain1.txt"),str_c(datawd,"2016_01_18_ss_Dore/simulation/N_vichy_realCODAindex.txt"))
N_vichy_real_q=array(NA,dim=c(44,5))#44 car il y a 17 année de suivi station (soit T+20 - 16)

#Attention à l'année 30 estimation des passages Vichy car année jugée incomplète
for (t in 1:22){
	N_vichy_real_q[t,]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}
for(t in 23:23){
	N_vichy_real_q[(t+7),]=quantile(bugs_N_vichy_real[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}

#N_vichy_proj_q=array(0,dim=c(43,5))
N_vichy_proj_q=array(0,dim=c(T+20,5))
for (t in (T+1):(T+20)){
	N_vichy_proj_q[t,]=quantile(dev_sd_N_vichy[,t],probs=c(0.025,0.25,0.5,0.75,0.975),names=FALSE)
}

#------------------
# Graph
#------------------
pdf(file=str_c(imgwd,"DevalMorta_TotalReturns_ssDore_proj20years_2016_03_14.pdf"))#,width=8,height=8)


plot(1,1,type="n",axes=FALSE,xlim=c(0.5,T+20+0.5),xlab="Années",ylim=c(0,9000),ylab="Retour à Vichy",main="Projection à 20 ans sans repeuplement - Suppression des mortalités \n à la dévalaison dans les 11 ouvrages hydroélectriques \n avec une hypothèse de production en juvéniles nulle sur la Dore",sub="Répartition des juvéniles au prorata des surfaces disponibles + prise en compte de la productivité des rivières",cex.sub=0.75,cex.lab=1.5)

# trace l'axe des ordonnées
axis(2,at = c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),labels=c(0,1000,2000,3000,4000,5000,6000,7000,8000,9000),cex.axis = 1.2,las = 1,lwd=2,col = "black")
# trace l'axe des abscisses
lab1=c(1975,1980,1990,2000,1974+T,1974+T+10,1974+T+20)
axis(1,at = c(1,6,16,26,T,T+10,T+20),
		labels=lab1,
		cex.axis = 1.2,las = 1,lwd=2,col = "black")


for(i in 3:30){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_real_q[i,5],i+0.15,N_vichy_real_q[i,5])
	segments(i,N_vichy_real_q[i,4],i,N_vichy_real_q[i,5])
	#5%
	segments(i-0.15,N_vichy_real_q[i,1],i+0.15,N_vichy_real_q[i,1])
	segments(i,N_vichy_real_q[i,2],i,N_vichy_real_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_real_q[i,2],N_vichy_real_q[i,2],N_vichy_real_q[i,4],N_vichy_real_q[i,4]),col="light grey")
	#median
	segments(i-0.3,N_vichy_real_q[i,3],i+0.3,N_vichy_real_q[i,3])
}


data_vichy=c(
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,NA,NA,NA,
		NA,NA,393,267,515,
		380,400,541,1238,NA,#662,
		510,950,572,421,491,
		227,755,861,819,595)
points(x=seq(23,T,1),data_vichy[23:T],pch=16)

for(i in (T+1):(T+20)){
	#whiskers
	#95%
	segments(i-0.15,N_vichy_proj_q[i,5],i+0.15,N_vichy_proj_q[i,5])
	segments(i,N_vichy_proj_q[i,4],i,N_vichy_proj_q[i,5])
	#5%
	segments(i-0.15,N_vichy_proj_q[i,1],i+0.15,N_vichy_proj_q[i,1])
	segments(i,N_vichy_proj_q[i,2],i,N_vichy_proj_q[i,1])
	#boxplot
	polygon(c(i-0.3,i+0.3,i+0.3,i-0.3),c(N_vichy_proj_q[i,2],N_vichy_proj_q[i,2],N_vichy_proj_q[i,4],N_vichy_proj_q[i,4]),col="orange")
	#median
	segments(i-0.3,N_vichy_proj_q[i,3],i+0.3,N_vichy_proj_q[i,3])
}


dev.off()

#==================================
# CHAP : Figure : Threshold
#==================================
#bugs_N_vichy=read.coda("N_vichyCODAchain1.txt","N_vichyCODAindex.txt")	

under_10_vichy=array(0,dim=c(8000,20))
under_50_vichy=array(0,dim=c(8000,20))
under_100_vichy=array(0,dim=c(8000,20))
under_250_vichy=array(0,dim=c(8000,20))
under_500_vichy=array(0,dim=c(8000,20))


for (t in (T+1):(T+20)){
	
	for (i in 1:5000){
		if(dev_sd_N_vichy[i,t] < 10){under_10_vichy[i,t-T]=1}  
		if(dev_sd_N_vichy[i,t] < 50){under_50_vichy[i,t-T]=1}
		if(dev_sd_N_vichy[i,t] < 100){under_100_vichy[i,t-T]=1}
		if(dev_sd_N_vichy[i,t] < 250){under_250_vichy[i,t-T]=1}
		if(dev_sd_N_vichy[i,t] < 500){under_500_vichy[i,t-T]=1}
		
	}
}


dev_sd_p_under_10_vichy=rep(0,20)
dev_sd_p_under_50_vichy=rep(0,20)
dev_sd_p_under_100_vichy=rep(0,20)
dev_sd_p_under_250_vichy=rep(0,20)
dev_sd_p_under_500_vichy=rep(0,20)


for (t in 1:20){
	dev_sd_p_under_10_vichy[t]=mean(under_10_vichy[,t])
	dev_sd_p_under_50_vichy[t]=mean(under_50_vichy[,t])
	dev_sd_p_under_100_vichy[t]=mean(under_100_vichy[,t])
	dev_sd_p_under_250_vichy[t]=mean(under_250_vichy[,t])
	dev_sd_p_under_500_vichy[t]=mean(under_500_vichy[,t])
	
}

#------------------------
# Graph
#------------------------
pdf(file=str_c(imgwd,"DevalaisonMorta_ssDore_Threshold_2016_03_14.pdf"))#,width=8,height=8)

par(mfrow=c(1,1),mar=c(4,6.1,2,0.5),cex.lab=1.4, cex.lab=1.4)

plot(1,1,type="n",axes=FALSE,xlim=c(0.5,20.5),xlab="Années",ylim=c(0,1),ylab=expression(italic(p^threshold)),main="",sub="Répartition des juvéniles au prorata des surfaces disponibles + prise en compte de la productivité des rivières",cex.sub=0.75)

# trace l'axe des ordonnées
axis(2,at = c(0,0.2,0.4,0.6,0.8,1),labels=c(0,0.2,0.4,0.6,0.8,1),cex.axis = 0.9,las = 1,col = "black")
# trace l'axe des abscisses
lab2=c(1975+T,1975+T+9,1975+T+19)
axis(1,at = c(1,10,20),
		labels=lab2,
		cex.axis = 0.9,las = 1,col = "black")

x=seq(1,20,1)



points(x,dev_sd_p_under_10_vichy,col="grey85",pch=16)
segments(x[1:19],dev_sd_p_under_10_vichy[1:19],x[2:20],dev_sd_p_under_10_vichy[2:20],col="grey85")

points(x,dev_sd_p_under_50_vichy,col="grey75",pch=16)
segments(x[1:19],dev_sd_p_under_50_vichy[1:19],x[2:20],dev_sd_p_under_50_vichy[2:20],col="grey75")

points(x,dev_sd_p_under_100_vichy,col="grey65",pch=16)
segments(x[1:19],dev_sd_p_under_100_vichy[1:19],x[2:20],dev_sd_p_under_100_vichy[2:20],col="grey65")

points(x,dev_sd_p_under_250_vichy,col="grey55",pch=16)
segments(x[1:19],dev_sd_p_under_250_vichy[1:19],x[2:20],dev_sd_p_under_250_vichy[2:20],col="grey55")

points(x,dev_sd_p_under_500_vichy,col="grey45",pch=16)
segments(x[1:19],dev_sd_p_under_500_vichy[1:19],x[2:20],dev_sd_p_under_500_vichy[2:20],col="grey45")


legend(15,1,legend=c(expression(p^treshold < 500),expression(p^treshold < 250),expression(p^treshold < 100),expression(p^treshold < 50),expression(p^treshold < 10)),
		pch=c(16,16,16,16,16),
		col=c("grey45","grey55","grey65","grey75","grey85"),
		bty="n" )


dev.off()
	
	
	
}
@



\paragraph*{Répartition des juvéniles au \textit{prorata} des surfaces
disponibles, avec prise en compte de la productivité des rivières}



\FloatBarrier

\clearpage

\chapter{Conclusion et perspectives du projet }

\section{Améliorations apportées au modèle}
\subsection{\textit{fitness}}
Le travail mené en 2015 a permis de conforter l'hypothèse initiale introduite
dans le modèle de survie similaire des juvéniles sauvages et d'élevage entre le
stade tacon 0+ et l'adulte de retour à Vichy (section \ref{fitness}). Néanmoins,
il semble probable que le succès reproducteur des poissons issus de déversement
(y compris à des stades précoces - alevins) soit moindre que celui des poissons
sauvages. Ainsi, dans les projections que nous réalisons sous l'hypothèse de
l'arrêt des déversements, nous avons sans doute tendance à être un peu
pessimiste sur la faculté de la population sauvage à se renouveler (puisque la
différence potentielle de succès reproducteur entre les deux origines n'est pas prise en compte dans le modèle, faute de données nous permettant de la faire).

\subsection{Relation de calibration entre les pêches en 5 minutes (IA) et les pêches complètes}
En 2015, 4 points supplémentaires ont pu être réalisés sur le double protocole
pêche indice d'abondance en 5 minutes (IA) et pêche complète, renforçant ainsi
la relation de calibration existante. Malheureusement, nous n'avons pu réaliser
un point à forte abondance (> 175 0+/5minutes). Un tel point serait néanmoins
précieux pour améliorer le calage de la relation pour des indices d'abondance
forts.\\
Une nouvelle campagne de pêche est prévue par LOGRAMI en 2016 (4 nouveaux
points). La réalisation d'un point à très forte abondance reste un objectif
pour cette future campagne. De même, comme en 2015, au moins un point de pêche sera
réalisé sur un des affluents de l'Allier inclus dans le territoire du modèle
(Dore ou Alagnon).\\
De façon générale, l'ajout de ces 4 nouveaux points dans la relation de
calibration a eu pour conséquence la révision à la hausse des densités de
0+/m\up{2} pour un même indice d'abondance.

\section{Retour vers le futur : Et si on n'avait jamais repeuplé ?}


\section{Viabilité de la population de saumon atlantique dans le bassin Allier
et projection à 20 ans sous différents scénarii}

<<tab_scenarii, echo=FALSE, eval=TRUE, results=hide>>=

if (chunk_true==1){
	
scenario<-c("Pas d'amélioration", "Amélioration à Poutès à hauteur de 50\\%","Amélioration à Poutès à hauteur de 100\\%","Amélioration de la survie à hauteur de 50\\%","Amélioration de la survie à hauteur de 100\\%", "Suppression des mortalités à la dévalaison")	
medV<-c(round(median(ras_N_vichy[,(T+20-4):(T+20)]),0),round(median(p50_N_vichy[,(T+20-4):(T+20)]),0),round(median(p100_N_vichy[,(T+20-4):(T+20)]),0),round(median(s50_N_vichy[,(T+20-4):(T+20)]),0),round(median(s100_N_vichy[,(T+20-4):(T+20)]),0),round(median(dev_N_vichy[,(T+20-4):(T+20)]),0))	
probaV<-c(round(mean(ras_p_under_500_vichy[16:20])*100,1),round(mean(p50_p_under_500_vichy[16:20])*100,1),round(mean(p100_p_under_500_vichy[16:20])*100,1),round(mean(s50_p_under_500_vichy[16:20])*100,1),round(mean(s100_p_under_500_vichy[16:20])*100,1),round(mean(dev_p_under_500_vichy[16:20])*100,1))

tab<-as.data.frame(cbind(scenario,medV,probaV))
#colnames(tab)<-c("Nb médian d'indiv. à Vichy","Proba. d'observer moins de 500 indiv. à Vichy")
#rownames(tab)<-c("Pas d'amélioration", "Amélioration à Poutès à hauteur de 50%","Amélioration à Poutès à hauteur de 100%","Amélioration de la survie à hauteur de 50%","Amélioration de la survie à hauteur de 100%", "Suppression des mortalités à la dévalaison")	

tratio<-latex(tab,        
		title=str_c(),
		rowname="",
		rowlabel="",
		where="ht",
		longtable=FALSE,
		col.just=strsplit("l l l", " ")[[1]],
		label="tab_scenar",
		caption="Résultats des projections à 20 ans sous l'hypothèse de l'arrêt des déversements et dans différents scénarii d'amélioration. medV=Nombre d'individus médian à Vichy sur les 5 dernières années de la période de projection, probaV=Probabilité d'observer moins de 500 individus à Vichy sur les 5 dernières années de la période de projection (en \\%).",
		caption.lot="Résultats des projections à 20 ans sous l'hypothèse de l'arrêt des déversements et dans différents scénarii d'amélioration",
		file=str_c(tabwd,"scenar.tex"))	

}
@

Les projections à 20 ans sans repeuplement ni amélioration indiquent une baisse
au cours du temps du nombre d'adultes de retour à Vichy, témoignant ainsi d'un
renouvellement insuffisant de la population.\\
Néanmoins, les différentes simulations réalisées mettent en évidence une réponse
positive de la population de saumons de l'Allier aux améliorations qui peuvent
être apportées. Le tableau \ref{tab_scenar} synthétisent les résultats obtenus
selon les différents scénarii.

%\input[width=0.9\textwidth]{\Sexpr{tabwd}scenar.tex}



\section{Perspectives pour ce projet}
\label{perspectives}

Un certain nombre d'améliorations et de développement sont envisagées et
pourraient être mis en \oe{}uvre dans les années futures. Il s'agirait notamment
de :
\begin{itemize}
    \item identifier explicitement l'Alagnon, c'est-à-dire sortir ce
    cours d'eau du secteur 1 pour en faire un secteur à part entière,
    \item analyser les causes des résidus atypiques du recrutement naturel en amont de Poutès
    observés sur les 8 dernières années,
    \item tester une hypothèse alternative à l'hypothèse de priorité aux
    juvéniles natifs,
    \item introduire une corrélation spatiale dans la stochasticité
    environnementale (c'est-à-dire considérer à l'échelle de nos secteurs que lorsque les conditions 
    environnementales sont propices dans un secteur, elles le sont également
    dans les autres), en particulier en ce qui concerne le recrutement et la
    survie des poissons de repeuplement,
    \item développer des scénarii incluant des stratégies alternatives de repeuplement en terme de lieux et quantités de poissons
    déversés.
\end{itemize}

En 2016, le développement du modèle se poursuivra. Le groupe de travail de
suivi du projet se réunira une à deux fois dans l'année pour que les choix de
modélisation soient en adéquation avec la vision des acteurs du bassin de
l'Allier et pour conforter l'appropriation du modèle par l'ensemble du
groupe.
\clearpage

\bibliographystyle{cjfas}
\bibliography{rapport_transfert_2015}

%\printglossaries
\clearpage
\appendix

\chapter{Présentation de la fiche-projet du modèle de
dynamique de population pour l'année 2015}
\label{Annexe1}
%\includepdf[pages=-]{\Sexpr{imgwd}FicheTravail2015.pdf}
\clearpage

\chapter{Relevés de décisions des réunions du groupe de suivi du projet
de modélisation}
\label{Annexe2}
%\includegraphics{2014_07_22_ReleveDecision.pdf}
%\includepdf[pages=-]{\Sexpr{imgwd}2014_07_22_ReleveDecision.pdf}
%\includepdf[pages=-]{\Sexpr{imgwd}2014_11_19_ReleveDecision.pdf}
%\includepdf[pages=-]{\Sexpr{imgwd}2015_07_06_ReleveDecision_GT.pdf}
\clearpage

\chapter{Récapitulation des modifications importantes apportées au modèle depuis 2014}
\label{Annexe3}

<<tab_avancement, echo=FALSE, eval=TRUE, results=hide>>=

#if (chunk_true==1){
	
annee<-c(rep(2014,4),rep(2015,3),rep(2016,2))	
avanc<-c("Conversion des surfaces productives selon la formule des ERR développée sur l'Allier (Minster&Bomassi, 1999)",
		"Prise en compte plus fine des surfaces sous influence des déversements (jusqu'à l'année 2005)",
		"Mise à jour des données 2012 et 2013",
		"Développement des projections liées au réaménagement de Poutès (50\\% d'amélioration et suppression de l'ouvrage)",
		"Différence de fitnsess entre les juvéniles issus de reproduction naturelle et les juvéniles déversés (bibliographie). Le travail n'a pas conclu sur l'utilité de modifier les hypothèses antérieures du modèle",
		"Mise à jour des données 2014",
		"Développement d'un scénario de gestion (simulation à 20 ans) concernant la suppression des impacts à la dévalaison dans les ouvrages hydroélectriques situés dans le secteur du modèle dynamique de population",
		"Ajout d'une quatrième zone dans le modèle en extrayant l'Alagnon du secteur aval du modèle qui comprenait jusque là l'Allier en aval de Langeac + la Dore + l'Alagnon",
		"Mise à jour des données 2015")	

tab<-as.data.frame(cbind(annee,avanc))

tavanc<-latex(tab,        
		title=str_c(),
		rowname="",
		rowlabel="",
		where="ht",
		longtable=FALSE,
		col.just=strsplit("l l l", " ")[[1]],
		rgroup=c("2014","2015","2016"),
		n.rgroup=table(tab$annee),
		label="avancement",
		caption="",
		caption.lot="",		
		file=str_c(tabwd,"tavanc_annee.tex"))	

#}
@

\input{\Sexpr{tabwd}tavanc_annee.tex}

\chapter{Densités prédites pour un
nombre de tacons 0+ capturé en 5 minutes}
\label{Annexe4}
%\includepdf[pages=-,nup=2x2,scale=1]{\Sexpr{tabwd}predictions_densites_MAJ2015.pdf}


\chapter{Présentation des paramètres estimés par le modèle}
\label{Annexe5}
\begin{landscape}
%\includepdf[pages=-,nup=1x2,landscape=TRUE]{SortieOpenbugs_parameters_rapport2015.pdf}
\end{landscape}
\clearpage

\chapter{Code du modèle 2016.01.20}
\label{Annexe6}
\begin{landscape}
%\includepdf[pages=-,nup=1x2,landscape=true]{\Sexpr{imgwd}model_Annexe5.pdf}
\end{landscape}

%\includepdf{\Sexpr{imgwd}RapportTdB_4emeCouverture.pdf}


\end{document}
